{"version":3,"file":"extension.js","mappings":"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","sources":["../../node_modules/js-md5/src/md5.js","../../node_modules/js-yaml/index.js","../../node_modules/js-yaml/lib/common.js","../../node_modules/js-yaml/lib/dumper.js","../../node_modules/js-yaml/lib/exception.js","../../node_modules/js-yaml/lib/loader.js","../../node_modules/js-yaml/lib/schema.js","../../node_modules/js-yaml/lib/schema/core.js","../../node_modules/js-yaml/lib/schema/default.js","../../node_modules/js-yaml/lib/schema/failsafe.js","../../node_modules/js-yaml/lib/schema/json.js","../../node_modules/js-yaml/lib/snippet.js","../../node_modules/js-yaml/lib/type.js","../../node_modules/js-yaml/lib/type/binary.js","../../node_modules/js-yaml/lib/type/bool.js","../../node_modules/js-yaml/lib/type/float.js","../../node_modules/js-yaml/lib/type/int.js","../../node_modules/js-yaml/lib/type/map.js","../../node_modules/js-yaml/lib/type/merge.js","../../node_modules/js-yaml/lib/type/null.js","../../node_modules/js-yaml/lib/type/omap.js","../../node_modules/js-yaml/lib/type/pairs.js","../../node_modules/js-yaml/lib/type/seq.js","../../node_modules/js-yaml/lib/type/set.js","../../node_modules/js-yaml/lib/type/str.js","../../node_modules/js-yaml/lib/type/timestamp.js","../../node_modules/path-browserify/index.js","../../node_modules/process/browser.js","../../shared/extension/index.ts","../../shared/extension/language/CodeActions.ts","../../shared/extension/language/Completions.ts","../../shared/extension/language/Diagnostics.ts","../../shared/extension/language/Hovering.ts","../../shared/extension/language/ValueCompletions.ts","../../shared/extension/panels/AutoCreatePanel.ts","../../shared/extension/panels/AutoCreateValuesPanel.ts","../../shared/extension/trees/index.ts","../../shared/extension/utilities/apis.ts","../../shared/extension/utilities/completions.ts","../../shared/extension/utilities/completionsProv1.ts","../../shared/extension/utilities/completionsProv2.ts","../../shared/extension/utilities/completionsProv3.ts","../../shared/extension/utilities/constants.ts","../../shared/extension/utilities/defs.ts","../../shared/extension/utilities/enums.ts","../../shared/extension/utilities/gpkg.ts","../../shared/extension/utilities/paths.ts","../../shared/extension/utilities/refs.ts","../../shared/extension/utilities/registration.ts","../../shared/extension/utilities/schemas.ts","../../shared/extension/utilities/webview.ts","../../shared/extension/utilities/yaml.ts",".././index.ts","../external commonjs \"vscode\"","../../node_modules/@xtracfg/core/build/index.js","../../node_modules/@xtracfg/transport-websocket/node_modules/async-mutex/index.mjs","../../node_modules/isomorphic-ws/browser.js","../../node_modules/@xtracfg/transport-websocket/build/index.browser.js","../../node_modules/yaml/browser/dist/nodes/identity.js","../../node_modules/yaml/browser/dist/visit.js","../../node_modules/yaml/browser/dist/doc/directives.js","../../node_modules/yaml/browser/dist/doc/anchors.js","../../node_modules/yaml/browser/dist/doc/applyReviver.js","../../node_modules/yaml/browser/dist/nodes/toJS.js","../../node_modules/yaml/browser/dist/nodes/Node.js","../../node_modules/yaml/browser/dist/nodes/Alias.js","../../node_modules/yaml/browser/dist/nodes/Scalar.js","../../node_modules/yaml/browser/dist/doc/createNode.js","../../node_modules/yaml/browser/dist/nodes/Collection.js","../../node_modules/yaml/browser/dist/stringify/stringifyComment.js","../../node_modules/yaml/browser/dist/stringify/foldFlowLines.js","../../node_modules/yaml/browser/dist/stringify/stringifyString.js","../../node_modules/yaml/browser/dist/stringify/stringify.js","../../node_modules/yaml/browser/dist/log.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js","../../node_modules/yaml/browser/dist/nodes/addPairToJSMap.js","../../node_modules/yaml/browser/dist/nodes/Pair.js","../../node_modules/yaml/browser/dist/stringify/stringifyPair.js","../../node_modules/yaml/browser/dist/stringify/stringifyCollection.js","../../node_modules/yaml/browser/dist/nodes/YAMLMap.js","../../node_modules/yaml/browser/dist/schema/common/map.js","../../node_modules/yaml/browser/dist/nodes/YAMLSeq.js","../../node_modules/yaml/browser/dist/schema/common/seq.js","../../node_modules/yaml/browser/dist/schema/common/string.js","../../node_modules/yaml/browser/dist/schema/common/null.js","../../node_modules/yaml/browser/dist/schema/core/bool.js","../../node_modules/yaml/browser/dist/stringify/stringifyNumber.js","../../node_modules/yaml/browser/dist/schema/core/float.js","../../node_modules/yaml/browser/dist/schema/core/int.js","../../node_modules/yaml/browser/dist/schema/core/schema.js","../../node_modules/yaml/browser/dist/schema/json/schema.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/float.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/int.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/set.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js","../../node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js","../../node_modules/yaml/browser/dist/schema/tags.js","../../node_modules/yaml/browser/dist/schema/Schema.js","../../node_modules/yaml/browser/dist/doc/Document.js","../../node_modules/yaml/browser/dist/stringify/stringifyDocument.js","../../node_modules/yaml/browser/dist/errors.js","../../node_modules/yaml/browser/dist/compose/resolve-props.js","../../node_modules/yaml/browser/dist/compose/util-contains-newline.js","../../node_modules/yaml/browser/dist/compose/util-flow-indent-check.js","../../node_modules/yaml/browser/dist/compose/util-map-includes.js","../../node_modules/yaml/browser/dist/compose/resolve-block-map.js","../../node_modules/yaml/browser/dist/compose/resolve-end.js","../../node_modules/yaml/browser/dist/compose/resolve-flow-collection.js","../../node_modules/yaml/browser/dist/compose/compose-collection.js","../../node_modules/yaml/browser/dist/compose/resolve-block-seq.js","../../node_modules/yaml/browser/dist/compose/resolve-block-scalar.js","../../node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js","../../node_modules/yaml/browser/dist/compose/compose-scalar.js","../../node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js","../../node_modules/yaml/browser/dist/compose/compose-node.js","../../node_modules/yaml/browser/dist/compose/composer.js","../../node_modules/yaml/browser/dist/compose/compose-doc.js","../../node_modules/yaml/browser/dist/parse/cst-scalar.js","../../node_modules/yaml/browser/dist/parse/cst-stringify.js","../../node_modules/yaml/browser/dist/parse/cst-visit.js","../../node_modules/yaml/browser/dist/parse/cst.js","../../node_modules/yaml/browser/dist/parse/lexer.js","../../node_modules/yaml/browser/dist/parse/line-counter.js","../../node_modules/yaml/browser/dist/parse/parser.js","../../node_modules/yaml/browser/dist/public-api.js","../../node_modules/yaml/browser/index.js","../webpack/bootstrap","../webpack/runtime/amd options","../webpack/runtime/define property getters","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/startup"],"sourcesContent":["/**\n * [js-md5]{@link https://github.com/emn178/js-md5}\n *\n * @namespace md5\n * @version 0.8.3\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2023\n * @license MIT\n */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_MD5_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [128, 32768, 8388608, -2147483648];\n  var SHIFT = [0, 8, 16, 24];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];\n  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n  var blocks = [], buffer8;\n  if (ARRAY_BUFFER) {\n    var buffer = new ArrayBuffer(68);\n    buffer8 = new Uint8Array(buffer);\n    blocks = new Uint32Array(buffer);\n  }\n\n  var isArray = Array.isArray;\n  if (root.JS_MD5_NO_NODE_JS || !isArray) {\n    isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  var isView = ArrayBuffer.isView;\n  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !isView)) {\n    isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  // [message: string, isString: bool]\n  var formatMessage = function (message) {\n    var type = typeof message;\n    if (type === 'string') {\n      return [message, true];\n    }\n    if (type !== 'object' || message === null) {\n      throw new Error(INPUT_ERROR);\n    }\n    if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n      return [new Uint8Array(message), false];\n    }\n    if (!isArray(message) && !isView(message)) {\n      throw new Error(INPUT_ERROR);\n    }\n    return [message, false];\n  }\n\n  /**\n   * @method hex\n   * @memberof md5\n   * @description Output hash as hex string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} Hex string\n   * @example\n   * md5.hex('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * md5('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method digest\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.digest('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method array\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.array('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method arrayBuffer\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.buffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method base64\n   * @memberof md5\n   * @description Output hash as base64 string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} base64 string\n   * @example\n   * md5.base64('The quick brown fox jumps over the lazy dog');\n   */\n  var createOutputMethod = function (outputType) {\n    return function (message) {\n      return new Md5(true).update(message)[outputType]();\n    };\n  };\n\n  /**\n   * @method create\n   * @memberof md5\n   * @description Create Md5 object\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.create();\n   */\n  /**\n   * @method update\n   * @memberof md5\n   * @description Create and update Md5 object\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.update('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * var hash = md5.create();\n   * hash.update('The quick brown fox jumps over the lazy dog');\n   */\n  var createMethod = function () {\n    var method = createOutputMethod('hex');\n    if (NODE_JS) {\n      method = nodeWrap(method);\n    }\n    method.create = function () {\n      return new Md5();\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method) {\n    var crypto = require('crypto')\n    var Buffer = require('buffer').Buffer;\n    var bufferFrom;\n    if (Buffer.from && !root.JS_MD5_NO_BUFFER_FROM) {\n      bufferFrom = Buffer.from;\n    } else {\n      bufferFrom = function (message) {\n        return new Buffer(message);\n      };\n    }\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash('md5').update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(INPUT_ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (isArray(message) || isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash('md5').update(bufferFrom(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  /**\n   * @namespace md5.hmac\n   */\n  /**\n   * @method hex\n   * @memberof md5.hmac\n   * @description Output hash as hex string\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} Hex string\n   * @example\n   * md5.hmac.hex('key', 'The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * md5.hmac('key', 'The quick brown fox jumps over the lazy dog');\n   */\n\n  /**\n   * @method digest\n   * @memberof md5.hmac\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.hmac.digest('key', 'The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method array\n   * @memberof md5.hmac\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.hmac.array('key', 'The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method arrayBuffer\n   * @memberof md5.hmac\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.hmac.arrayBuffer('key', 'The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof md5.hmac\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.hmac.buffer('key', 'The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method base64\n   * @memberof md5.hmac\n   * @description Output hash as base64 string\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} base64 string\n   * @example\n   * md5.hmac.base64('key', 'The quick brown fox jumps over the lazy dog');\n   */\n  var createHmacOutputMethod = function (outputType) {\n    return function (key, message) {\n      return new HmacMd5(key, true).update(message)[outputType]();\n    };\n  };\n\n  /**\n   * @method create\n   * @memberof md5.hmac\n   * @description Create HmacMd5 object\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @returns {HmacMd5} HmacMd5 object.\n   * @example\n   * var hash = md5.hmac.create('key');\n   */\n  /**\n   * @method update\n   * @memberof md5.hmac\n   * @description Create and update HmacMd5 object\n   * @param {String|Array|Uint8Array|ArrayBuffer} key key\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {HmacMd5} HmacMd5 object.\n   * @example\n   * var hash = md5.hmac.update('key', 'The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * var hash = md5.hmac.create('key');\n   * hash.update('The quick brown fox jumps over the lazy dog');\n   */\n  var createHmacMethod = function () {\n    var method = createHmacOutputMethod('hex');\n    method.create = function (key) {\n      return new HmacMd5(key);\n    };\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type);\n    }\n    return method;\n  };\n\n  /**\n   * Md5 class\n   * @class Md5\n   * @description This is internal class.\n   * @see {@link md5.create}\n   */\n  function Md5(sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n      this.buffer8 = buffer8;\n    } else {\n      if (ARRAY_BUFFER) {\n        var buffer = new ArrayBuffer(68);\n        this.buffer8 = new Uint8Array(buffer);\n        this.blocks = new Uint32Array(buffer);\n      } else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      }\n    }\n    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n  }\n\n  /**\n   * @method update\n   * @memberof Md5\n   * @instance\n   * @description Update hash\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @see {@link md5.update}\n   */\n  Md5.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n\n    var result = formatMessage(message);\n    message = result[0];\n    var isString = result[1];\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    var buffer8 = this.buffer8;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = blocks[16];\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (isString) {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              buffer8[i++] = code;\n            } else if (code < 0x800) {\n              buffer8[i++] = 0xc0 | (code >>> 6);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else if (code < 0xd800 || code >= 0xe000) {\n              buffer8[i++] = 0xe0 | (code >>> 12);\n              buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              buffer8[i++] = 0xf0 | (code >>> 18);\n              buffer8[i++] = 0x80 | ((code >>> 12) & 0x3f);\n              buffer8[i++] = 0x80 | ((code >>> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            }\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n            } else if (code < 0x800) {\n              blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n              blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else if (code < 0xd800 || code >= 0xe000) {\n              blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n              blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n              blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            }\n          }\n        }\n      } else {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            buffer8[i++] = message[index];\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Md5.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[i >>> 2] |= EXTRA[i & 3];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = blocks[16];\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.bytes << 3;\n    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;\n    this.hash();\n  };\n\n  Md5.prototype.hash = function () {\n    var a, b, c, d, bc, da, blocks = this.blocks;\n\n    if (this.first) {\n      a = blocks[0] - 680876937;\n      a = (a << 7 | a >>> 25) - 271733879 << 0;\n      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;\n      b = (b << 22 | b >>> 10) + c << 0;\n    } else {\n      a = this.h0;\n      b = this.h1;\n      c = this.h2;\n      d = this.h3;\n      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;\n      a = (a << 7 | a >>> 25) + b << 0;\n      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;\n      b = (b << 22 | b >>> 10) + c << 0;\n    }\n\n    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;\n    b = (b << 20 | b >>> 12) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[5] - 378558;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[8] - 2022574463;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[11] + 1839030562;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[14] - 35309556;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[1] - 1530992060;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[4] + 1272893353;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[7] - 155497632;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[10] - 1094730640;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[13] + 681279174;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[0] - 358537222;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[3] - 722521979;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[6] + 76029189;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[9] - 640364487;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[12] - 421815835;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[15] + 530742520;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[2] - 995338651;\n    b = (b << 23 | b >>> 9) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[0] - 198630844;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[5] - 57434055;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[10] - 1051523;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[15] - 30611744;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[4] - 145523070;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[2] + 718787259;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[9] - 343485551;\n    b = (b << 21 | b >>> 11) + c << 0;\n\n    if (this.first) {\n      this.h0 = a + 1732584193 << 0;\n      this.h1 = b - 271733879 << 0;\n      this.h2 = c - 1732584194 << 0;\n      this.h3 = d + 271733878 << 0;\n      this.first = false;\n    } else {\n      this.h0 = this.h0 + a << 0;\n      this.h1 = this.h1 + b << 0;\n      this.h2 = this.h2 + c << 0;\n      this.h3 = this.h3 + d << 0;\n    }\n  };\n\n  /**\n   * @method hex\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.hex();\n   */\n  Md5.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n\n    return HEX_CHARS[(h0 >>> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h0 >>> 12) & 0x0F] + HEX_CHARS[(h0 >>> 8) & 0x0F] +\n      HEX_CHARS[(h0 >>> 20) & 0x0F] + HEX_CHARS[(h0 >>> 16) & 0x0F] +\n      HEX_CHARS[(h0 >>> 28) & 0x0F] + HEX_CHARS[(h0 >>> 24) & 0x0F] +\n      HEX_CHARS[(h1 >>> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h1 >>> 12) & 0x0F] + HEX_CHARS[(h1 >>> 8) & 0x0F] +\n      HEX_CHARS[(h1 >>> 20) & 0x0F] + HEX_CHARS[(h1 >>> 16) & 0x0F] +\n      HEX_CHARS[(h1 >>> 28) & 0x0F] + HEX_CHARS[(h1 >>> 24) & 0x0F] +\n      HEX_CHARS[(h2 >>> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h2 >>> 12) & 0x0F] + HEX_CHARS[(h2 >>> 8) & 0x0F] +\n      HEX_CHARS[(h2 >>> 20) & 0x0F] + HEX_CHARS[(h2 >>> 16) & 0x0F] +\n      HEX_CHARS[(h2 >>> 28) & 0x0F] + HEX_CHARS[(h2 >>> 24) & 0x0F] +\n      HEX_CHARS[(h3 >>> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h3 >>> 12) & 0x0F] + HEX_CHARS[(h3 >>> 8) & 0x0F] +\n      HEX_CHARS[(h3 >>> 20) & 0x0F] + HEX_CHARS[(h3 >>> 16) & 0x0F] +\n      HEX_CHARS[(h3 >>> 28) & 0x0F] + HEX_CHARS[(h3 >>> 24) & 0x0F];\n  };\n\n  /**\n   * @method toString\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.toString();\n   */\n  Md5.prototype.toString = Md5.prototype.hex;\n\n  /**\n   * @method digest\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.digest}\n   * @example\n   * hash.digest();\n   */\n  Md5.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n    return [\n      h0 & 0xFF, (h0 >>> 8) & 0xFF, (h0 >>> 16) & 0xFF, (h0 >>> 24) & 0xFF,\n      h1 & 0xFF, (h1 >>> 8) & 0xFF, (h1 >>> 16) & 0xFF, (h1 >>> 24) & 0xFF,\n      h2 & 0xFF, (h2 >>> 8) & 0xFF, (h2 >>> 16) & 0xFF, (h2 >>> 24) & 0xFF,\n      h3 & 0xFF, (h3 >>> 8) & 0xFF, (h3 >>> 16) & 0xFF, (h3 >>> 24) & 0xFF\n    ];\n  };\n\n  /**\n   * @method array\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.array}\n   * @example\n   * hash.array();\n   */\n  Md5.prototype.array = Md5.prototype.digest;\n\n  /**\n   * @method arrayBuffer\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.arrayBuffer}\n   * @example\n   * hash.arrayBuffer();\n   */\n  Md5.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(16);\n    var blocks = new Uint32Array(buffer);\n    blocks[0] = this.h0;\n    blocks[1] = this.h1;\n    blocks[2] = this.h2;\n    blocks[3] = this.h3;\n    return buffer;\n  };\n\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.buffer}\n   * @example\n   * hash.buffer();\n   */\n  Md5.prototype.buffer = Md5.prototype.arrayBuffer;\n\n  /**\n   * @method base64\n   * @memberof Md5\n   * @instance\n   * @description Output hash as base64 string\n   * @returns {String} base64 string\n   * @see {@link md5.base64}\n   * @example\n   * hash.base64();\n   */\n  Md5.prototype.base64 = function () {\n    var v1, v2, v3, base64Str = '', bytes = this.array();\n    for (var i = 0; i < 15;) {\n      v1 = bytes[i++];\n      v2 = bytes[i++];\n      v3 = bytes[i++];\n      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n        BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] +\n        BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] +\n        BASE64_ENCODE_CHAR[v3 & 63];\n    }\n    v1 = bytes[i];\n    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n      BASE64_ENCODE_CHAR[(v1 << 4) & 63] +\n      '==';\n    return base64Str;\n  };\n\n  /**\n   * HmacMd5 class\n   * @class HmacMd5\n   * @extends Md5\n   * @description This is internal class.\n   * @see {@link md5.hmac.create}\n   */\n  function HmacMd5(key, sharedMemory) {\n    var i, result = formatMessage(key);\n    key = result[0];\n    if (result[1]) {\n      var bytes = [], length = key.length, index = 0, code;\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = (0xc0 | (code >>> 6));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = (0xe0 | (code >>> 12));\n          bytes[index++] = (0x80 | ((code >>> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));\n          bytes[index++] = (0xf0 | (code >>> 18));\n          bytes[index++] = (0x80 | ((code >>> 12) & 0x3f));\n          bytes[index++] = (0x80 | ((code >>> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        }\n      }\n      key = bytes;\n    }\n\n    if (key.length > 64) {\n      key = (new Md5(true)).update(key).array();\n    }\n\n    var oKeyPad = [], iKeyPad = [];\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Md5.call(this, sharedMemory);\n\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n  HmacMd5.prototype = new Md5();\n\n  HmacMd5.prototype.finalize = function () {\n    Md5.prototype.finalize.call(this);\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Md5.call(this, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Md5.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.md5 = exports;\n  exports.md5.hmac = createHmacMethod();\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    /**\n     * @method md5\b\n     * @description Md5 hash function, export to global in browsers.\n     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n     * @returns {String} md5 hashes\n     * @example\n     * md5(''); // d41d8cd98f00b204e9800998ecf8427e\n     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6\n     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0\n     *\n     * // It also supports UTF-8 encoding\n     * md5(''); // a7bac2239fcdcb3a067903d8077c4a07\n     *\n     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`\n     * md5([]); // d41d8cd98f00b204e9800998ecf8427e\n     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e\n     */\n    root.md5 = exports;\n    if (AMD) {\n      define(function () {\n        return exports;\n      });\n    }\n  }\n})();\n","'use strict';\n\n\nvar loader = require('./lib/loader');\nvar dumper = require('./lib/dumper');\n\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nmodule.exports.Type                = require('./lib/type');\nmodule.exports.Schema              = require('./lib/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./lib/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./lib/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./lib/schema/core');\nmodule.exports.DEFAULT_SCHEMA      = require('./lib/schema/default');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.YAMLException       = require('./lib/exception');\n\n// Re-export all types in case user wants to create custom schema\nmodule.exports.types = {\n  binary:    require('./lib/type/binary'),\n  float:     require('./lib/type/float'),\n  map:       require('./lib/type/map'),\n  null:      require('./lib/type/null'),\n  pairs:     require('./lib/type/pairs'),\n  set:       require('./lib/type/set'),\n  timestamp: require('./lib/type/timestamp'),\n  bool:      require('./lib/type/bool'),\n  int:       require('./lib/type/int'),\n  merge:     require('./lib/type/merge'),\n  omap:      require('./lib/type/omap'),\n  seq:       require('./lib/type/seq'),\n  str:       require('./lib/type/str')\n};\n\n// Removed functions from JS-YAML 3.0.x\nmodule.exports.safeLoad            = renamed('safeLoad', 'load');\nmodule.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nmodule.exports.safeDump            = renamed('safeDump', 'dump');\n","'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n","'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnt mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out\n//                             c = flow-in    ns-plain-safe-in\n//                             c = block-key  ns-plain-safe-out\n//                             c = flow-key   ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )\n//                            | ( /* An ns-char preceding */ # )\n//                            | ( : /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // - | ? | : | , | [ | ] | { | }\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | # | & | * | ! | | | = | > | ' | \"\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | % | @ | `)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//     No ending newline => unaffected; already using strip \"-\" chomping.\n//     Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -\n      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #\n      //                         | ; | / | ? | : | @ | & | = | + | $ | ,\n      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n","// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nmodule.exports = YAMLException;\n","'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar makeSnippet         = require('./snippet');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = makeSnippet(mark);\n\n  return new YAMLException(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    // used for this specific key only because Object.defineProperty is slow\n    if (keyNode === '__proto__') {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nmodule.exports.loadAll = loadAll;\nmodule.exports.load    = load;\n","'use strict';\n\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n","// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nmodule.exports = require('./json');\n","// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nmodule.exports = require('./core').extend({\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n","// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n","// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nmodule.exports = require('./failsafe').extend({\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n","'use strict';\n\n\nvar common = require('./common');\n\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nmodule.exports = makeSnippet;\n","'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n","'use strict';\n\n/*eslint-disable no-bitwise*/\n\n\nvar Type = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n","'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n","'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n","'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import { ExtensionContext, TextDocument, window, workspace } from \"vscode\";\n\nimport { registerShowAutoCreate } from \"./panels/AutoCreatePanel\";\nimport { registerShowAutoCreateValues } from \"./panels/AutoCreateValuesPanel\";\n\nimport { registerDiagnostics, updateDiagnostics } from \"./language/Diagnostics\";\nimport { registerCompletions, updateCompletions } from \"./language/Completions\";\nimport { registerValueCompletions, updateValueCompletions } from \"./language/ValueCompletions\";\nimport { registerHover, updateHover } from \"./language/Hovering\";\nimport { registerCodeActions } from \"./language/CodeActions\";\nimport { DEV } from \"./utilities/constants\";\nimport { initSchemas } from \"./utilities/schemas\";\nimport { parseYaml, hashText } from \"./utilities/yaml\";\nimport { Registration, register, DocEvent } from \"./utilities/registration\";\nimport { registeTreeViews } from \"./trees\";\nimport { TransportCreator } from \"@xtracfg/core\";\n\nexport type Transport = {\n  transport: TransportCreator;\n  additionalTransportOptions: Record<string, any>;\n};\n\nlet initialized = false;\n\nexport function activate(\n  context: ExtensionContext,\n  transportCreator: TransportCreator,\n  additionalTransportOptions: Record<string, any> = {}\n) {\n  if (initialized) {\n    return;\n  }\n\n  if (DEV) {\n    console.log(\n      \"ACTIVATE\",\n      context.extension.id,\n      context.extension.isActive,\n      context.extensionMode\n    );\n  }\n\n  const transport: Transport = { transport: transportCreator, additionalTransportOptions };\n\n  initialized = true;\n\n  initSchemas(transport);\n\n  register(\n    context,\n    transport,\n    registeTreeViews,\n    registerShowAutoCreate,\n    registerShowAutoCreateValues,\n    registerHover,\n    registerCompletions,\n    registerValueCompletions,\n    registerDiagnostics,\n    registerDocHandlers,\n    registerCodeActions\n  );\n\n  onDocUpdate(DocEvent.OPEN, window.activeTextEditor?.document);\n}\n\nexport function deactivate() {}\n\nconst registerDocHandlers: Registration = () => {\n  return [\n    window.onDidChangeActiveTextEditor((editor) => {\n      const document = window.activeTextEditor?.document;\n      if (document && editor) {\n        onDocUpdate(DocEvent.OPEN, document);\n      }\n    }),\n    workspace.onDidChangeTextDocument((event) => {\n      const document = window.activeTextEditor?.document;\n      if (document) {\n        const activeEditor = window.activeTextEditor;\n        if (activeEditor && event.document === activeEditor.document) {\n          onDocUpdate(DocEvent.CHANGE, document);\n        }\n      }\n    }),\n    workspace.onDidSaveTextDocument((document) => {\n      if (document) {\n        onDocUpdate(DocEvent.SAVE, document);\n      }\n    }),\n  ];\n};\n\nexport const onDocUpdate = function (event: DocEvent, document?: TextDocument) {\n  if (document) {\n    const text = document.getText();\n    const uri = document.uri.toString();\n    const hash = hashText(text);\n\n    if (hash && hash !== \"\") {\n      const allYamlKeys = parseYaml(text);\n\n      updateHover(event, document, uri, hash, allYamlKeys);\n      updateCompletions(event, document, uri, hash, allYamlKeys);\n      updateValueCompletions(event, document, uri, hash, allYamlKeys);\n      updateDiagnostics(event, document, uri, hash, allYamlKeys);\n    }\n  }\n};\n","import * as vscode from \"vscode\";\nimport { Registration } from \"../utilities/registration\";\n\n// First tests for code actions\nexport const registerCodeActions: Registration = () => {\n  return [\n    /*vscode.languages.registerCodeActionsProvider(\"yaml\", new Emojinfo(), {\n      providedCodeActionKinds: Emojinfo.providedCodeActionKinds,\n    }),\n    vscode.commands.registerCommand(\"code-actions-sample.command\", () =>\n      vscode.env.openExternal(\n        vscode.Uri.parse(\"https://unicode.org/emoji/charts-12.0/full-emoji-list.html\")\n      )\n    ),*/\n  ];\n};\n\nclass Emojinfo implements vscode.CodeActionProvider {\n  public static readonly providedCodeActionKinds = [vscode.CodeActionKind.QuickFix];\n\n  provideCodeActions(\n    document: vscode.TextDocument,\n    range: vscode.Range | vscode.Selection,\n    context: vscode.CodeActionContext,\n    token: vscode.CancellationToken\n  ): vscode.CodeAction[] {\n    return context.diagnostics.map((diagnostic) => this.createCommandCodeAction(diagnostic));\n  }\n\n  private createCommandCodeAction(diagnostic: vscode.Diagnostic): vscode.CodeAction {\n    const action = new vscode.CodeAction(\"Learn more...\", vscode.CodeActionKind.QuickFix);\n    action.command = {\n      command: \"code-actions-sample.command\",\n      title: \"Learn more about emojis\",\n      tooltip: \"This will open the unicode emoji page.\",\n    };\n    action.diagnostics = [diagnostic];\n    action.isPreferred = true;\n    return action;\n  }\n}\n","import * as vscode from \"vscode\";\nimport { extractDocRefs } from \"../utilities/refs\";\nimport {\n  extractIndexFromPath,\n  getIndentation,\n  getMaxLine,\n  AllYamlKeys,\n  getLinesForArrayIndex,\n  indentationOfYamlObjectAboveCursor,\n} from \"../utilities/yaml\";\nimport { getDefinitionsMap, DefinitionsMap } from \"../utilities/defs\";\nimport { removeDuplicates } from \"../utilities/refs\";\nimport { DEV } from \"../utilities/constants\";\nimport { getSchema } from \"../utilities/schemas\";\nimport { buildEnumArray } from \"../utilities/enums\";\nimport { DocUpdate, Registration } from \"../utilities/registration\";\nimport { shouldShowCompletionsProv1, getRefCompletionsProv1 } from \"../utilities/completionsProv1\";\nimport { gatherInformation, getPathAtCursor } from \"../utilities/completions\";\nimport { shouldFilterExistingCharacters, createCompletionItem } from \"../utilities/completions\";\nimport { shouldShowCompletionsProv2 } from \"../utilities/completionsProv2\";\nimport {\n  shouldShowCompletionsProv3,\n  createCompletionItemProv3,\n} from \"../utilities/completionsProv3\";\n\nlet enumArray: { key: string; enum: string; groupname: string }[];\n\nlet allYamlKeys: AllYamlKeys;\nlet definitionsMap: DefinitionsMap = {};\nlet specifiedDefs: { ref: string; finalPath: string }[];\n\nexport const updateCompletions: DocUpdate = async function (\n  event,\n  document,\n  docUri,\n  docHash,\n  newAllYamlKeys\n) {\n  allYamlKeys = newAllYamlKeys;\n  const schema = await getSchema();\n  const text = document.getText();\n  if (text) {\n    if (text && schema) {\n      enumArray = buildEnumArray(schema);\n      specifiedDefs = extractDocRefs(text, schema, docUri, docHash);\n      const uniqueDefs = removeDuplicates(specifiedDefs);\n      definitionsMap = getDefinitionsMap(schema, uniqueDefs, docUri, docHash);\n      console.log(\"enumArray\", enumArray);\n      console.log(\"specifiedDefs\", uniqueDefs);\n      console.log(\"definitionsMap\", definitionsMap);\n    }\n  }\n};\n\nexport const registerCompletions: Registration = () => {\n  return [\n    vscode.languages.registerCompletionItemProvider(\"yaml\", referencesFromSpecifiedDefs),\n    vscode.languages.registerCompletionItemProvider(\"yaml\", nonIndentedKeysAndArrays),\n    vscode.languages.registerCompletionItemProvider(\"yaml\", additionalReferencesFromSpecifiedDefs),\n  ];\n};\n\nconst referencesFromSpecifiedDefs: vscode.CompletionItemProvider<vscode.CompletionItem> = {\n  provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n    const {\n      textBeforeCursor,\n      textBeforeCursorLength,\n      indentation,\n      indentationOfpathAtCursor,\n      line,\n      column,\n      indentationUsedInYaml,\n      pathAtCursor,\n    } = gatherInformation(position, document, allYamlKeys);\n\n    let currentStartOfArray = allYamlKeys.find(\n      (item) => item.lineOfPath === line - 1\n    )?.startOfArray;\n\n    // If there is a hyphen in the line, it's a new object and doesn't belong to the one above\n    const myLine = document.lineAt(line - 1).text;\n    console.log(\"myLine\", myLine);\n    if (myLine.trim().startsWith(\"-\")) {\n      currentStartOfArray = -1;\n    }\n\n    if (DEV) {\n      console.log(\"textBeforeCursor1\", textBeforeCursor.trim(), indentation);\n      console.log(\"pathAtCursor: \" + pathAtCursor);\n      console.log(\"definitionsMapCompletions\", definitionsMap);\n      console.log(\"currentArrayIndex: \" + currentStartOfArray);\n    }\n\n    if (\n      shouldShowCompletionsProv1(\n        textBeforeCursor,\n        column,\n        indentationOfpathAtCursor,\n        indentationUsedInYaml,\n        textBeforeCursorLength,\n        currentStartOfArray\n      )\n    ) {\n      return getRefCompletionsProv1(\n        pathAtCursor,\n        currentStartOfArray,\n        textBeforeCursor,\n        definitionsMap,\n        DEV,\n        allYamlKeys,\n        enumArray\n      );\n    }\n  },\n};\n\nconst nonIndentedKeysAndArrays: vscode.CompletionItemProvider<vscode.CompletionItem> = {\n  provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n    const {\n      textBeforeCursor,\n      textBeforeCursorLength,\n      indentation,\n      indentationOfpathAtCursor,\n      line,\n      column,\n      indentationUsedInYaml,\n      pathAtCursor,\n    } = gatherInformation(position, document, allYamlKeys);\n\n    const completions: vscode.CompletionItem[] = [];\n    const uniqueDefs = removeDuplicates(specifiedDefs);\n    if (DEV) {\n      console.log(\"allYamlKeysInProvider2: \", allYamlKeys);\n      console.log(\"pathAtCursorProvider2: \" + pathAtCursor);\n      console.log(\"uniqueDefsInProvider2\", uniqueDefs);\n      console.log(\"textBeforeCursor2\", textBeforeCursor, indentation);\n    }\n\n    uniqueDefs.forEach((defObj) => {\n      const ref = defObj.ref;\n      const path = defObj.finalPath;\n      const pathSplit = path.split(\".\");\n      const specifiedDefsPath = pathSplit.slice(0, -1).join(\".\");\n      const arrayIndex = extractIndexFromPath(path);\n      const minLine = getLinesForArrayIndex(\n        allYamlKeys,\n        arrayIndex ? arrayIndex : 0,\n        specifiedDefsPath\n      );\n      let maxLine: number | undefined;\n      if (minLine) {\n        maxLine = getMaxLine(allYamlKeys, minLine, document);\n      }\n      const keyAtStartOfArray = allYamlKeys.find((key) => key.lineOfPath === minLine);\n      const columnOfArray = keyAtStartOfArray ? keyAtStartOfArray.index : 0;\n\n      if (DEV) {\n        console.log(\"minmax\", minLine, maxLine, line);\n        console.log(\"speziu2\", specifiedDefsPath, pathAtCursor);\n        console.log(\"keyAtStartOfArray: \", keyAtStartOfArray);\n      }\n\n      if (\n        !specifiedDefsPath.includes(\"[\") &&\n        pathAtCursor !== undefined &&\n        pathAtCursor === specifiedDefsPath &&\n        definitionsMap\n      ) {\n        /*  Explanation if statement: completions only when position of cursor equal to:\n      1. Non indented and no letters typed -> Just the standardIdentation (e.g. 2 again)\n      2. Same but with letters already typed, so plus the already typed letters */\n        if (\n          (textBeforeCursor.trim() === \"\" && column === 0) ||\n          (textBeforeCursor.trim() !== \"\" && column === textBeforeCursorLength)\n        ) {\n          for (const key in definitionsMap) {\n            if (definitionsMap.hasOwnProperty(key)) {\n              const obj = definitionsMap[key];\n              if (obj.groupname === ref) {\n                const value = obj.title;\n                if (\n                  value !== undefined &&\n                  obj.deprecated !== true &&\n                  allYamlKeys &&\n                  !allYamlKeys.some((key) => {\n                    const fullPath = specifiedDefsPath ? `${specifiedDefsPath}.${value}` : value;\n                    return key.path === fullPath;\n                  })\n                ) {\n                  const completion = createCompletionItem(value, obj, enumArray, DEV);\n                  const filterExistingCharacters = shouldFilterExistingCharacters(\n                    textBeforeCursor,\n                    value\n                  );\n                  if (filterExistingCharacters) {\n                    completions.push(completion);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else if (\n        specifiedDefsPath.includes(\"[\") &&\n        minLine !== undefined &&\n        line >= minLine &&\n        maxLine !== undefined &&\n        line < maxLine &&\n        definitionsMap &&\n        (indentation === columnOfArray || column === columnOfArray)\n      ) {\n        if (\n          shouldShowCompletionsProv2(\n            pathAtCursor,\n            textBeforeCursor,\n            column,\n            indentationOfpathAtCursor,\n            indentationUsedInYaml,\n            textBeforeCursorLength\n          )\n        ) {\n          if (DEV) {\n            console.log(\"columnOfArray\", columnOfArray);\n            console.log(\"speziu\", specifiedDefsPath, pathAtCursor);\n            console.log(\"MyMinLine\", minLine);\n          }\n\n          for (const key in definitionsMap) {\n            if (definitionsMap.hasOwnProperty(key)) {\n              const obj = definitionsMap[key];\n              if (obj.groupname === ref) {\n                if (DEV) {\n                  console.log(\"refProvider2\", ref);\n                }\n                const value = obj.title;\n                if (\n                  value !== undefined &&\n                  obj.deprecated !== true &&\n                  allYamlKeys &&\n                  !allYamlKeys.some((key) => {\n                    const fullPath = pathAtCursor ? `${pathAtCursor}.${value}` : value;\n                    return key.path === fullPath && key.startOfArray === minLine;\n                  })\n                ) {\n                  const completion = createCompletionItem(value, obj, enumArray, DEV);\n                  const filterExistingCharacters = shouldFilterExistingCharacters(\n                    textBeforeCursor,\n                    value\n                  );\n                  const existing = completions.find((existingComp) => existingComp.label === value);\n                  if (filterExistingCharacters && existing === undefined) {\n                    completions.push(completion);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n    return completions;\n  },\n};\n\nconst additionalReferencesFromSpecifiedDefs: vscode.CompletionItemProvider<vscode.CompletionItem> =\n  {\n    provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n      const {\n        textBeforeCursor,\n        textBeforeCursorLength,\n        indentation,\n        indentationOfpathAtCursor,\n        line,\n        column,\n        indentationUsedInYaml,\n        pathAtCursor,\n      } = gatherInformation(position, document, allYamlKeys);\n\n      if (DEV) {\n        console.log(\"pathAtCursorInProvider3: \" + pathAtCursor);\n        console.log(\"textBeforeCursor3\", textBeforeCursor, indentation);\n      }\n      const uniqueDefs = removeDuplicates(specifiedDefs);\n\n      if (Object.keys(definitionsMap).length > 0) {\n        const refCompletions: vscode.CompletionItem[] = [];\n        for (const key in definitionsMap) {\n          if (definitionsMap.hasOwnProperty(key)) {\n            const obj = definitionsMap[key];\n            if (obj.addRef && obj[\"addRef\"] !== \"\") {\n              if (DEV) {\n                console.log(\"objProvider3\", obj);\n              }\n              const title = obj.title; // e.g. \"collections\"\n              const value = obj.addRef; // e.g. \"FeatureTypeConfigurationOgcApi\"\n              if (\n                title !== undefined &&\n                value !== undefined &&\n                pathAtCursor !== undefined &&\n                new RegExp(`${title}\\\\.\\\\w*$`).test(pathAtCursor) // Is cursor at a point where there is a key with an addRef 2 lines before?\n              ) {\n                let arrayIndex: number | undefined = -1;\n                let addRefOfObjInArray: string | undefined = \"\";\n                let refinedObjPath: string | undefined;\n                let objPath: string | undefined;\n                let foundObj:\n                  | {\n                      path: string;\n                      index: number;\n                      lineOfPath: number;\n                      startOfArray?: number | undefined;\n                      arrayIndex?: number | undefined;\n                    }\n                  | undefined;\n                for (let i = line; i >= 0; i--) {\n                  foundObj = allYamlKeys.find((obj) => {\n                    const lastDotIndex = obj.path.lastIndexOf(\".\");\n                    const pathAfterLastDot = obj.path.substring(lastDotIndex + 1);\n                    return obj.lineOfPath === i && pathAfterLastDot === title;\n                  }); // foundObject is the object in allYamlKeys which has the addRef\n                  if (foundObj) {\n                    if (DEV) {\n                      console.log(\"foundObjPrv3: \", foundObj, foundObj?.arrayIndex);\n                    }\n                    break;\n                  }\n                }\n                // Next 33 lines only for case addRef in ARRAY\n                // Why is that necessary (potentially hypothetical example): the key \"transformations\" in buildingBlock: GLTF has another addRef as the property \"transfomations\" in \"CollectionsConfiguration\" (buildingBlock: COLLECTIONS). Hence it is important to know, in which ref the key \"transformations\" is in.\n                if (foundObj && foundObj.arrayIndex && foundObj.path) {\n                  arrayIndex = foundObj.arrayIndex;\n                  objPath = foundObj.path;\n                  const partsInObjPath = objPath.split(\".\").slice(0, -1);\n                  refinedObjPath = partsInObjPath.join(\".\");\n                  if (DEV) {\n                    console.log(\"uniqueDefsProv3\", uniqueDefs);\n                    console.log(\"arayIndexProvider3: \", arrayIndex, foundObj.path, refinedObjPath);\n                  }\n                }\n                let relevantRefs = [\"\"];\n\n                if (arrayIndex !== -1 && refinedObjPath) {\n                  relevantRefs = uniqueDefs\n                    .filter(\n                      (obj) =>\n                        obj.finalPath.includes(`[${arrayIndex}]`) &&\n                        obj.finalPath.split(\".\").slice(0, -2).join(\".\") === refinedObjPath\n                    )\n                    .map((obj) => obj.ref); // Here the possible groupnames of the addRef are being extracted (e.g \"CollectionsConfiguration\" or \"CommonConfiguration\")\n\n                  relevantRefs.forEach((ref) => {\n                    if (obj.groupname === ref) {\n                      // if object with the addRef has the same groupname as the ref of the path in specifiedDefs. The ref in specifiedDefs is the one our property with the addRef(e.g. \"transformations\" or \"collections\") is in. We found this ref by finding the array we are in by using the path of foundObject (the property with the addRef) and its arrayIndex.\n                      if (DEV) {\n                        console.log(\"obj.addRefProvider3\", obj.addRef);\n                      }\n                      addRefOfObjInArray = obj.addRef; // then addRefOfObjInArray is = the addRef we found in the beginning and saved in value\n                    }\n                  });\n                }\n                // here we push all keys as completions, which have the same groupname as the addRef in question\n                // For explanation of if statement see Provider1\n                if (\n                  shouldShowCompletionsProv3(\n                    textBeforeCursor,\n                    arrayIndex,\n                    column,\n                    indentationOfpathAtCursor,\n                    indentationUsedInYaml,\n                    textBeforeCursorLength\n                  )\n                ) {\n                  for (const key2 in definitionsMap) {\n                    if (definitionsMap.hasOwnProperty(key2)) {\n                      const obj2 = definitionsMap[key2];\n\n                      let finalValue: string = \"\";\n                      // case Array\n                      if (\n                        addRefOfObjInArray !== \"\" &&\n                        addRefOfObjInArray !== undefined &&\n                        obj2.groupname === addRefOfObjInArray &&\n                        obj2.title\n                      ) {\n                        if (DEV) {\n                          console.log(\"addRefOfObjInArray: \", addRefOfObjInArray);\n                        }\n                        finalValue = obj2.title;\n                      } else if (\n                        arrayIndex === -1 &&\n                        obj2 &&\n                        obj2.title &&\n                        obj2.groupname === value\n                      ) {\n                        finalValue = obj2.title;\n                      }\n                      if (DEV) {\n                        console.log(\"finalValue: \", finalValue);\n                      }\n                      if (\n                        finalValue !== \"\" &&\n                        obj2.deprecated !== true &&\n                        allYamlKeys &&\n                        !allYamlKeys.some((key) => key.path === `${pathAtCursor}.${finalValue}`)\n                      ) {\n                        const completion = createCompletionItemProv3(\n                          finalValue,\n                          obj2,\n                          enumArray,\n                          DEV\n                        );\n\n                        const filterExistingCharacters = shouldFilterExistingCharacters(\n                          textBeforeCursor,\n                          finalValue\n                        );\n\n                        const existing = refCompletions.find(\n                          (existingComp) => existingComp.label === finalValue\n                        );\n                        if (filterExistingCharacters && existing === undefined) {\n                          if (DEV) {\n                            console.log(\"completion3\", finalValue);\n                            console.log(\"insertText3\", completion.insertText);\n                          }\n                          if (\n                            completion.detail === \"Enum\" ||\n                            completion.detail === \"obj\" ||\n                            completion.detail === \"array\"\n                          ) {\n                            completion.command = {\n                              title: \"Trigger Suggest\",\n                              command: \"editor.action.triggerSuggest\",\n                            };\n                          }\n                          refCompletions.push(completion);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return refCompletions;\n      }\n    },\n  };\n","import * as vscode from \"vscode\";\nimport { connect, TransportCreator, Xtracfg } from \"@xtracfg/core\";\nimport { getRelativeFilePath, getWorkspacePath } from \"../utilities/paths\";\nimport { DEV } from \"../utilities/constants\";\nimport { DocEvent, DocUpdate, Registration } from \"../utilities/registration\";\nimport { type Transport } from \"..\";\n\nlet xtracfg: Xtracfg;\n\nconst diagnosticsResults: {\n  [key: string]: {\n    result: Promise<string[]>;\n    resolve: (result: string[]) => void;\n    reject: (reason: string) => void;\n    pending: boolean;\n  };\n} = {};\n\nconst collection = vscode.languages.createDiagnosticCollection(\"ldproxy-editor\");\n\nexport const registerDiagnostics: Registration = (\n  context,\n  { transport, additionalTransportOptions }: Transport\n) => {\n  xtracfg = connect(transport, { specific: additionalTransportOptions, debug: DEV });\n\n  xtracfg.listen(\n    (response) => {\n      if (DEV) {\n        console.log(\"RESP\", response);\n      }\n      if (response.results && response.details && response.details.path) {\n        if (Object.hasOwn(diagnosticsResults, response.details.path)) {\n          const results = response.results\n            .filter((result) => result.status === \"INFO\")\n            .map((result) => {\n              const match = result.message;\n\n              return match ? match : \"\";\n            });\n          if (DEV) {\n            console.log(\"DIAGNOSTICS\", results);\n          }\n          diagnosticsResults[response.details.path].resolve(results);\n          diagnosticsResults[response.details.path].pending = false;\n        }\n      }\n    },\n    (error) => {\n      console.error(\"ERR\", error);\n    }\n  );\n\n  return [];\n};\n\nconst requestDiagnostics = async (path: string): Promise<string[]> => {\n  if (!path) {\n    return Promise.resolve([]);\n  }\n\n  if (diagnosticsResults[path] && diagnosticsResults[path].pending) {\n    return diagnosticsResults[path].result;\n  }\n\n  const results: any = {};\n  results.result = new Promise((resolve, reject) => {\n    results.resolve = resolve;\n    results.reject = reject;\n  });\n\n  diagnosticsResults[path] = results;\n\n  xtracfg.send({\n    command: \"check\",\n    subcommand: \"entities\",\n    source: getWorkspacePath(),\n    path: path,\n    verbose: true,\n    debug: true,\n  });\n\n  return diagnosticsResults[path].result;\n};\n\nexport const updateDiagnostics: DocUpdate = async function (\n  event,\n  document,\n  docUri,\n  docHash,\n  newAllYamlKeys\n) {\n  if (event !== DocEvent.OPEN && event !== DocEvent.SAVE) {\n    return;\n  }\n\n  if (DEV) {\n    console.log(\"yamlKeysDiagnosticUpdateDiagnostics\", newAllYamlKeys);\n  }\n\n  const diagnostics: vscode.Diagnostic[] = [];\n  const path = getRelativeFilePath(document.uri);\n\n  if (!path) {\n    return;\n  }\n\n  const results = await requestDiagnostics(path);\n\n  results.forEach((info) => {\n    const infoText = info.match(/\\$.\\S*/);\n    if (DEV) {\n      console.log(\"infoText\", info, infoText);\n    }\n    let infoWord = infoText ? infoText[0].trim() : \"\";\n\n    if (infoWord.startsWith(\"$.\")) {\n      infoWord = infoWord.substring(2);\n    }\n    if (infoWord.endsWith(\":\")) {\n      infoWord = infoWord.slice(0, -1);\n    }\n\n    const infoWordWithoutIndex = infoWord.replace(/\\[\\d+\\]/g, \"\");\n    if (DEV) {\n      console.log(\"infoWord:\", infoWord);\n      console.log(\"withoutIndex\", infoWordWithoutIndex);\n    }\n    try {\n      const keys = infoWord.split(\".\");\n      const lastKey: string = keys[keys.length - 1];\n      const matches = [...infoWord.matchAll(/\\[(\\d+)\\]/g)];\n      const lastMatch = matches[matches.length - 1];\n      let index: number | null = null;\n      if (lastMatch && lastMatch[1]) {\n        index = parseInt(lastMatch[1], 10);\n      }\n      let lastKeyIndex: number | undefined;\n\n      let lineOfPath: number | null = 0;\n      if (DEV) {\n        console.log(\"Keys\", keys, lastKey, lastMatch);\n        console.log(\"indexUpdateDiagnostics\", keys, \":\", index, lastMatch);\n      }\n      if (index !== null) {\n        const foundItem = newAllYamlKeys.find(\n          (item) => item.path === infoWordWithoutIndex && item.arrayIndex === index\n        );\n        if (DEV) {\n          console.log(\"foundItemIndex\", foundItem);\n        }\n        if (foundItem) {\n          lineOfPath = foundItem.lineOfPath - 1;\n        }\n      } else {\n        const foundItem = newAllYamlKeys.find((item) => item.path === infoWord);\n        if (DEV) {\n          console.log(\"foundItem\", foundItem);\n        }\n        if (foundItem) {\n          lineOfPath = foundItem.lineOfPath - 1;\n        }\n      }\n      if (DEV) {\n        console.log(\"lineOfPath\", lineOfPath);\n      }\n      if (lineOfPath && lineOfPath !== 0) {\n        const lineText = document.lineAt(lineOfPath).text;\n        if (DEV) {\n          console.log(\"lineText\", lineText);\n        }\n        if (lineText.includes(lastKey)) {\n          const keyIndex = lineText.indexOf(lastKey);\n          const lineTextIndex = document.offsetAt(new vscode.Position(lineOfPath, 0));\n\n          lastKeyIndex = lineTextIndex + keyIndex;\n        }\n\n        const startPosition = document.positionAt(lastKeyIndex ? lastKeyIndex : 0);\n        const endPosition = document.positionAt(lastKeyIndex ? lastKeyIndex + lastKey.length : 0);\n\n        if (lastKeyIndex !== -1) {\n          const diagnostic = new vscode.Diagnostic(\n            new vscode.Range(startPosition, endPosition),\n            `${info}`,\n            vscode.DiagnosticSeverity.Warning\n          );\n\n          diagnostics.push(diagnostic);\n        }\n      } else {\n        console.error(`Key \"${lastKey}\" not found in path \"${infoWord}\"`);\n      }\n    } catch (e) {\n      console.error(\"Error parsing YAML:\", e);\n    }\n  });\n\n  collection.set(document.uri, diagnostics);\n};\n","import * as vscode from \"vscode\";\nimport { extractDocRefs } from \"../utilities/refs\";\nimport { getDefinitionsMap, DefinitionsMap, LooseDefinition } from \"../utilities/defs\";\nimport {\n  extractIndexFromPath,\n  getMaxLine,\n  AllYamlKeys,\n  getLinesForArrayIndex,\n  hashDoc,\n} from \"../utilities/yaml\";\nimport { DEV } from \"../utilities/constants\";\nimport { getSchema } from \"../utilities/schemas\";\nimport { DocUpdate, Registration } from \"../utilities/registration\";\n\nlet yamlKeysHover: AllYamlKeys;\nlet specifiedDefs: { ref: string; finalPath: string }[];\nlet definitionsMap: DefinitionsMap = {};\n\nexport const updateHover: DocUpdate = async function (\n  event,\n  document,\n  docUri,\n  docHash,\n  newAllYamlKeys\n) {\n  yamlKeysHover = newAllYamlKeys;\n  const schema = await getSchema();\n  const text = document.getText();\n  if (text && schema) {\n    specifiedDefs = extractDocRefs(text, schema, docUri, docHash);\n    if (DEV) {\n      console.log(\"specifiedDefsGetSchema\", specifiedDefs);\n    }\n    if (specifiedDefs && specifiedDefs.length > 0) {\n      definitionsMap = getDefinitionsMap(schema, specifiedDefs, docUri, docHash);\n    }\n  }\n};\n\nlet hoverStatus: {\n  [docUri: string]: { hash: string; results: { [lineCharacter: string]: vscode.Hover } };\n} = {};\n\nexport const registerHover: Registration = () => {\n  return [vscode.languages.registerHoverProvider(\"yaml\", hover)];\n};\n\nconst hover: vscode.HoverProvider = {\n  provideHover(document, position) {\n    const docUri = document.uri.toString();\n    const docHash = hashDoc(document);\n    const lineOfWord: number = position.line + 1;\n    //NOTE: if yaml flow syntax should be supported, then use: `${lineOfWord}_${position.character}`\n    const lineCharacter = `${lineOfWord}`;\n\n    if (\n      docUri &&\n      docHash &&\n      hoverStatus[docUri] &&\n      hoverStatus[docUri].hash === docHash &&\n      Object.keys(hoverStatus[docUri].results).includes(lineCharacter)\n    ) {\n      if (DEV) {\n        console.log(\"hoverStatus\", hoverStatus);\n      }\n      return hoverStatus[docUri].results[lineCharacter];\n    }\n\n    if (DEV) {\n      console.log(\"yamlKeysHover\", yamlKeysHover);\n    }\n\n    const pathInYaml = yamlKeysHover.find((item) => item.lineOfPath === lineOfWord);\n    const pathSplit = pathInYaml?.path.split(\".\");\n    const pathInYamlToUse = pathSplit?.slice(0, -1).join(\".\");\n    const pathInYamlLastKey = pathSplit?.slice(-1)[0];\n    let wordInDefinitionsMap: LooseDefinition = {};\n    let hoverResult: vscode.Hover | undefined;\n    specifiedDefs.forEach((defObj) => {\n      if (DEV) {\n        console.log(\"defObjHover\", defObj);\n      }\n      const ref = defObj.ref;\n      const path = defObj.finalPath;\n      const pathSplit = path.split(\".\");\n      const specifiedDefsPath = pathSplit.slice(0, -1).join(\".\");\n      const pathForArray = pathSplit.slice(0, -2).join(\".\");\n      const arrayIndex = extractIndexFromPath(path);\n      const minLine = getLinesForArrayIndex(\n        yamlKeysHover,\n        arrayIndex ? arrayIndex : 0,\n        specifiedDefsPath\n      );\n      let maxLine: number | undefined;\n      if (minLine) {\n        maxLine = getMaxLine(yamlKeysHover, minLine, document);\n      }\n      if (pathInYaml) {\n        if (DEV) {\n          console.log(\"specifiedDefs\", specifiedDefs);\n          console.log(\"hoverPathForArray\", pathForArray);\n          console.log(\"hoverMinMax\", minLine, maxLine, lineOfWord);\n          console.log(\"hoverSpecifiedPath\", specifiedDefsPath);\n          console.log(\"hoverPathToUse\", pathInYamlToUse);\n          console.log(\"hoverpathInYamlLastKey\", pathInYamlLastKey);\n          console.log(\"hoverPathInYaml\", pathInYaml);\n        }\n      }\n      // case1: word part of a ref of specifiedDefs whose path is no array (e.g. not buildingBlock [e.g. not CollectionsConfiguration])\n      // Also not refs or addRefs\n      if (\n        !specifiedDefsPath.includes(\"[\") &&\n        pathInYamlToUse === specifiedDefsPath &&\n        definitionsMap &&\n        pathInYaml &&\n        definitionsMap.hasOwnProperty(pathInYaml.path)\n      ) {\n        for (const key in definitionsMap) {\n          const obj = definitionsMap[key];\n          if (obj.title === pathInYaml.path && ref === obj.groupname) {\n            wordInDefinitionsMap = obj;\n            break;\n          }\n        }\n\n        if (\n          wordInDefinitionsMap &&\n          wordInDefinitionsMap.description !== \"\" &&\n          wordInDefinitionsMap.description !== undefined\n        ) {\n          const hoverText = `${wordInDefinitionsMap.title}: ${wordInDefinitionsMap.description}`;\n          hoverResult = new vscode.Hover(hoverText);\n        }\n        //Case2: Array\n      } else if (\n        specifiedDefsPath.includes(\"[\") &&\n        pathInYamlToUse === pathForArray &&\n        minLine !== undefined &&\n        maxLine !== undefined &&\n        lineOfWord >= minLine &&\n        lineOfWord < maxLine &&\n        definitionsMap &&\n        pathInYaml &&\n        pathInYamlLastKey &&\n        definitionsMap.hasOwnProperty(pathInYamlLastKey)\n      ) {\n        if (DEV) {\n          console.log(\"neuesMinMax\", minLine, maxLine, lineOfWord);\n        }\n        for (const key in definitionsMap) {\n          const obj = definitionsMap[key];\n          if (\n            obj.title === pathInYamlLastKey &&\n            ref === obj.groupname &&\n            definitionsMap[pathInYamlLastKey].description !== \"\"\n          ) {\n            if (DEV) {\n              console.log(\"TTTTTest\", obj);\n            }\n            wordInDefinitionsMap = obj;\n            break;\n          }\n        }\n\n        if (\n          wordInDefinitionsMap &&\n          wordInDefinitionsMap.description !== \"\" &&\n          wordInDefinitionsMap.description !== undefined\n        ) {\n          const hoverText = `${wordInDefinitionsMap.title}: ${wordInDefinitionsMap.description}`;\n          hoverResult = new vscode.Hover(hoverText);\n        }\n        //case3: refs and then addRefs\n      } else {\n        const pathInYamlParts = pathInYaml?.path.split(\".\");\n        let lastKey = \"\";\n        let secondLastKey = \"\";\n        let thirdLastKey = \"\";\n        if (pathInYamlParts) {\n          lastKey = pathInYamlParts[pathInYamlParts.length - 1];\n          secondLastKey = pathInYamlParts[pathInYamlParts.length - 2];\n          thirdLastKey = pathInYamlParts[pathInYamlParts.length - 3];\n          if (DEV) {\n            console.log(\"addRef1\", thirdLastKey, lastKey);\n          }\n        }\n        // case ref\n        if (\n          definitionsMap.hasOwnProperty(secondLastKey) &&\n          definitionsMap.hasOwnProperty(lastKey)\n        ) {\n          let matchingObjects = [];\n\n          for (const key in definitionsMap) {\n            const obj = definitionsMap[key];\n            if (obj.title === lastKey && obj.description !== \"\") {\n              matchingObjects.push(obj);\n            }\n          }\n\n          let possibleRefWord;\n          let matchingObject;\n          for (const key in definitionsMap) {\n            const obj = definitionsMap[key];\n            if (obj.title === secondLastKey && obj.ref !== \"\") {\n              matchingObject = matchingObjects.find(\n                (matchingObj) => matchingObj.groupname === obj.ref\n              );\n\n              if (matchingObject) {\n                possibleRefWord = obj;\n                break;\n              }\n            }\n          }\n          if (DEV) {\n            console.log(\"secRef\", matchingObject);\n          }\n          if (\n            matchingObject &&\n            possibleRefWord &&\n            matchingObject.description &&\n            matchingObject.description !== undefined\n          ) {\n            const hoverText = `${matchingObject.title}: ${matchingObject.description}`;\n            hoverResult = new vscode.Hover(hoverText);\n          }\n        }\n\n        // case addRef\n        if (definitionsMap.hasOwnProperty(thirdLastKey) && definitionsMap.hasOwnProperty(lastKey)) {\n          if (DEV) {\n            console.log(\"addRefThird\", thirdLastKey, lastKey);\n          }\n\n          let matchingObjects = [];\n\n          for (const key in definitionsMap) {\n            const obj = definitionsMap[key];\n            if (obj.title === lastKey && obj.description !== \"\") {\n              matchingObjects.push(obj);\n            }\n          }\n\n          let possibleAddRefWord;\n          let matchingObject;\n          for (const key in definitionsMap) {\n            const obj = definitionsMap[key];\n            if (obj.title === thirdLastKey && obj.addRef !== \"\") {\n              matchingObject = matchingObjects.find(\n                (matchingObj) => matchingObj.groupname === obj.addRef\n              );\n\n              if (matchingObject) {\n                possibleAddRefWord = obj;\n                break;\n              }\n            }\n          }\n          if (DEV) {\n            console.log(\"thirdLastCase\", matchingObject);\n          }\n          if (\n            matchingObject &&\n            possibleAddRefWord &&\n            matchingObject.description &&\n            matchingObject.description !== undefined\n          ) {\n            const hoverText = `${matchingObject.title}: ${matchingObject.description}`;\n            hoverResult = new vscode.Hover(hoverText);\n          }\n        }\n        if (DEV) {\n          console.log(\"specifiedDefs1\", specifiedDefs);\n        }\n        if (docUri && docHash && lineCharacter && hoverResult) {\n          if (hoverStatus[docUri] && hoverStatus[docUri].hash === docHash) {\n            hoverStatus[docUri].results[lineCharacter] = hoverResult;\n          } else {\n            hoverStatus[docUri] = { hash: docHash, results: { [lineCharacter]: hoverResult } };\n          }\n        }\n        return hoverResult;\n      }\n    });\n    if (DEV) {\n      console.log(\"definitionsMap\", definitionsMap);\n    }\n    if (docUri && docHash && lineCharacter && hoverResult) {\n      if (hoverStatus[docUri] && hoverStatus[docUri].hash === docHash) {\n        hoverStatus[docUri].results[lineCharacter] = hoverResult;\n      } else {\n        hoverStatus[docUri] = { hash: docHash, results: { [lineCharacter]: hoverResult } };\n      }\n    }\n    return hoverResult;\n  },\n};\n\n/*\nUrsprngliche Hover Logik ab Line 52(nicht mehr ganz aktuell):\n\nLine von word herausfinden.\nPath in allYamlKeys finden.\n\nIndex=0: SpecifiedDefs sind ja die ursprnglichen. Wenn der Groupnname des Wortes in definitionsMap identisch mit \neinem der specifiedDefs ist, dann soll die dazugehrige Description fr das passende Wort, falls es Index 0 hat, \nangezeigt werden.\n\nPassende Descriptions fr Index>0: Alle Objekte mit ref aus definitionsMap herausfiltern. \nWenn das Wort in definitionsMap gefunden wurde, soll die Beschreibung nur angezeigt werden, wenn der \nvorletzte Teil des Pfades ein ref hat. Das Wort muss in der DefinitionsMap dann den groupname dieses refs haben.\n\nOder falls es sich im additionalProperty handelt:\n\nAlle Objekte mit addRef aus definitionsMap herausfiltern. \nWenn das Wort in definitionsMap gefunden wurde, soll die Beschreibung nur angezeigt werden, wenn der \n3. letzte Teil des Pfades in definitionsMap ein addRef hat. Das Wort muss in der DefinitionsMap dann den groupname \ndieses addRefs haben.\n*/\n","import * as vscode from \"vscode\";\nimport { buildEnumArray } from \"../utilities/enums\";\nimport { getSchema } from \"../utilities/schemas\";\nimport { getDefinitionsMap } from \"../utilities/defs\";\nimport { removeDuplicates } from \"../utilities/refs\";\nimport { extractDocRefs } from \"../utilities/refs\";\nimport { DEV } from \"../utilities/constants\";\nimport { AllYamlKeys } from \"../utilities/yaml\";\nimport { DocUpdate, Registration } from \"../utilities/registration\";\nimport { TransportCreator } from \"@xtracfg/core\";\n\ninterface LooseDefinition {\n  title?: string;\n  description?: string;\n  [key: string]: any;\n}\n\ninterface DefinitionsMap {\n  [key: string]: LooseDefinition;\n}\n\nlet allYamlKeys: AllYamlKeys;\nlet definitionsMap: DefinitionsMap = {};\nlet specifiedDefs: { ref: string; finalPath: string }[];\nlet uniqueDefs: any;\n\nexport const updateValueCompletions: DocUpdate = async function (\n  event,\n  document,\n  docUri,\n  docHash,\n  newAllYamlKeys\n) {\n  allYamlKeys = newAllYamlKeys;\n  const schema = await getSchema();\n  const text = document.getText();\n  if (text && schema) {\n    specifiedDefs = extractDocRefs(text, schema, docUri, docHash);\n    uniqueDefs = removeDuplicates(specifiedDefs);\n    if (uniqueDefs && uniqueDefs.length > 0) {\n      definitionsMap = getDefinitionsMap(schema, uniqueDefs, docUri, docHash);\n    }\n  }\n};\n\nexport const registerValueCompletions: Registration = () => {\n  return [vscode.languages.registerCompletionItemProvider(\"yaml\", provider())];\n};\n\nconst provider = (): vscode.CompletionItemProvider<vscode.CompletionItem> => ({\n  async provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {\n    const schema = await getSchema();\n\n    if (!schema) {\n      return [];\n    }\n    if (DEV) {\n      console.log(\"schemaVC: \", schema);\n    }\n    const enumArray: { key: string; enum: string; groupname: string }[] = buildEnumArray(schema);\n    if (DEV) {\n      console.log(\"enumArrayVC\", enumArray);\n      console.log(\"valueCompletionsAllYamlKeysVC\", allYamlKeys);\n    }\n\n    // When a few letters of the key are already typed when hitting auto completion\n    const lineText: string = document.lineAt(position.line).text;\n    const lastColonIndex: number = lineText.lastIndexOf(\":\");\n\n    const textBetweenColonAndCursor: string =\n      lastColonIndex !== -1\n        ? lineText.substring(lastColonIndex + 1, position.character).trim()\n        : \"\";\n\n    const valueCompletions: vscode.CompletionItem[] = [];\n    const line = position.line;\n    const keyAtCursor = findKeyForValueCompletion(line, document, position);\n    const yamlKeysObject = allYamlKeys.find((obj) => obj.lineOfPath === line + 1);\n    let pathAtCursor = \"\";\n    if (yamlKeysObject) {\n      pathAtCursor = yamlKeysObject.path;\n    }\n    let pathAtCursorTwoLastParts = \"\";\n    let pathAtCursorThreeLastParts = \"\";\n    if (pathAtCursor && pathAtCursor.length > 0) {\n      const pathAtCursorSplit = pathAtCursor.split(\".\");\n      pathAtCursorTwoLastParts = pathAtCursorSplit.slice(-2).join(\".\");\n      pathAtCursorThreeLastParts = pathAtCursorSplit.slice(-3).join(\".\");\n    }\n    if (DEV) {\n      console.log(\"keyAtCursorVC\", keyAtCursor);\n      console.log(\"pathAtCursorssssssVC\", pathAtCursor);\n      console.log(\"yamlKeysObjectVC\", yamlKeysObject);\n      console.log(\"pathAtCursorTwoLastPartsVC\", pathAtCursorTwoLastParts);\n      console.log(\"pathAtCursorThreeLastPartsVC\", pathAtCursorThreeLastParts);\n      console.log(\"definitionsMapVC\", definitionsMap);\n      console.log(\"allYamlKeysVC\", allYamlKeys);\n      console.log(\"uniqeDefsVC\", uniqueDefs);\n    }\n\n    enumArray.forEach((enumObj) => {\n      if (enumObj.hasOwnProperty(\"key\")) {\n        const key = enumObj.key;\n        const myEnum = enumObj.enum;\n        const enumGroupname = enumObj.groupname;\n        if (\n          key !== undefined &&\n          myEnum !== undefined &&\n          keyAtCursor !== \"\" &&\n          keyAtCursor === key\n        ) {\n          if (definitionsMap) {\n            for (const key in definitionsMap) {\n              if (definitionsMap.hasOwnProperty(key)) {\n                const obj = definitionsMap[key];\n                // case addRef\n                if (obj[\"addRef\"] !== \"\") {\n                  const title = obj.title;\n                  const value = obj.addRef;\n                  if (\n                    title !== undefined &&\n                    value !== undefined &&\n                    enumGroupname === value &&\n                    new RegExp(`${title}\\\\.\\\\b\\\\w+\\\\b\\\\.${keyAtCursor}`).test(\n                      pathAtCursorThreeLastParts\n                    )\n                  ) {\n                    if (DEV) {\n                      console.log(\"valueCompletionsKeyVC1\", myEnum);\n                    }\n                    const completion = new vscode.CompletionItem(myEnum);\n                    completion.kind = vscode.CompletionItemKind.Method;\n                    completion.command = {\n                      command: \"editor.action.ldproxy: Create new entities\",\n                      title: \"Re-trigger completions...\",\n                    };\n                    const existing = valueCompletions.find(\n                      (existingComp) => existingComp.label === myEnum\n                    );\n\n                    let filterExistingCharacters = false;\n                    if (textBetweenColonAndCursor !== \"\") {\n                      filterExistingCharacters = myEnum.startsWith(textBetweenColonAndCursor);\n                      if (DEV) {\n                        console.log(\"fECVC\", filterExistingCharacters);\n                      }\n                    } else {\n                      filterExistingCharacters = true;\n                    }\n\n                    if (filterExistingCharacters && existing === undefined) {\n                      valueCompletions.push(completion);\n                    }\n                  }\n                }\n                // case ref\n                else if (obj[\"ref\"] !== \"\") {\n                  const title = obj.title;\n                  const value = obj.ref;\n                  if (DEV) {\n                    console.log(\"titleVCRef\", title);\n                    console.log(\"enumGroupnameVCRef\", enumGroupname);\n                    console.log(\"pathAtCursorTwoLastPartsVCRef\", pathAtCursorTwoLastParts);\n                    console.log(\"keyAtCursorVCRef\", keyAtCursor);\n                  }\n                  if (\n                    title !== undefined &&\n                    value !== undefined &&\n                    enumGroupname === value &&\n                    pathAtCursorTwoLastParts === `${title}.${keyAtCursor}`\n                  ) {\n                    if (DEV) {\n                      console.log(\"valueCompletionsKeyVC2\", myEnum);\n                    }\n                    const completion = new vscode.CompletionItem(myEnum);\n                    completion.kind = vscode.CompletionItemKind.Method;\n                    completion.command = {\n                      command: \"editor.action.ldproxy: Create new entities\",\n                      title: \"Re-trigger completions...\",\n                    };\n                    const existing = valueCompletions.find(\n                      (existingComp) => existingComp.label === myEnum\n                    );\n\n                    let filterExistingCharacters = false;\n                    if (textBetweenColonAndCursor !== \"\") {\n                      filterExistingCharacters = myEnum.startsWith(textBetweenColonAndCursor);\n                      if (DEV) {\n                        console.log(\"fECVC\", filterExistingCharacters);\n                      }\n                    } else {\n                      filterExistingCharacters = true;\n                    }\n\n                    if (filterExistingCharacters && existing === undefined) {\n                      valueCompletions.push(completion);\n                    }\n                  }\n                  // case non indented\n                } else {\n                  uniqueDefs.forEach((def: any) => {\n                    if (\n                      key !== undefined &&\n                      myEnum !== undefined &&\n                      (def.ref === enumGroupname || enumGroupname === \"\") &&\n                      !pathAtCursor.includes(\".\")\n                    ) {\n                      if (DEV) {\n                        console.log(\"valueCompletionsKeyVC3\", myEnum);\n                      }\n                      const completion = new vscode.CompletionItem(myEnum);\n                      completion.kind = vscode.CompletionItemKind.Method;\n                      completion.command = {\n                        command: \"editor.action.ldproxy: Create new entities\",\n                        title: \"Re-trigger completions...\",\n                      };\n                      const existing = valueCompletions.find(\n                        (existingComp) => existingComp.label === myEnum\n                      );\n\n                      let filterExistingCharacters = false;\n                      if (textBetweenColonAndCursor !== \"\") {\n                        filterExistingCharacters = myEnum.startsWith(textBetweenColonAndCursor);\n                        if (DEV) {\n                          console.log(\"fECVC\", filterExistingCharacters);\n                        }\n                      } else {\n                        filterExistingCharacters = true;\n                      }\n\n                      if (filterExistingCharacters && existing === undefined) {\n                        valueCompletions.push(completion);\n                      }\n                      // case Array\n                    } else if (\n                      key !== undefined &&\n                      myEnum !== undefined &&\n                      def.ref === enumGroupname &&\n                      def.finalPath.includes(\"[\")\n                    ) {\n                      const completion = new vscode.CompletionItem(myEnum);\n                      completion.kind = vscode.CompletionItemKind.Method;\n                      completion.command = {\n                        command: \"editor.action.ldproxy: Create new entities\",\n                        title: \"Re-trigger completions...\",\n                      };\n                      const existing = valueCompletions.find(\n                        (existingComp) => existingComp.label === myEnum\n                      );\n\n                      let filterExistingCharacters = false;\n                      if (textBetweenColonAndCursor !== \"\") {\n                        filterExistingCharacters = myEnum.startsWith(textBetweenColonAndCursor);\n                        if (DEV) {\n                          console.log(\"fECVC\", filterExistingCharacters);\n                        }\n                      } else {\n                        filterExistingCharacters = true;\n                      }\n\n                      if (filterExistingCharacters && existing === undefined) {\n                        valueCompletions.push(completion);\n                      }\n                    }\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    });\n\n    return valueCompletions;\n  },\n});\n\nfunction findKeyForValueCompletion(line: number, document: vscode.TextDocument, position: any) {\n  const textBeforeCursor = document.getText(\n    new vscode.Range(new vscode.Position(line, 0), position)\n  );\n\n  let textBeforeColon = \"\";\n  if (textBeforeCursor.includes(\":\")) {\n    const lastIndex = textBeforeCursor.lastIndexOf(\":\");\n    const substringBeforeColon = textBeforeCursor.substring(0, lastIndex).trim();\n\n    const lastSpaceIndex = substringBeforeColon.lastIndexOf(\" \");\n\n    if (lastSpaceIndex !== -1) {\n      textBeforeColon = substringBeforeColon.substring(lastSpaceIndex + 1);\n    } else {\n      textBeforeColon = substringBeforeColon; // Wenn kein Leerzeichen vorhanden ist\n    }\n    if (DEV) {\n      console.log(\"Text vor dem Doppelpunkt:\", textBeforeColon);\n    }\n  }\n  return textBeforeColon;\n}\n\n/*\nPfad bercksichtigen Flle:\n\nGibt es in DefMap eine prop mit ref oder addRef mit dem Groupname?\nDann genau wie in Completions vorgehen: Entweder der part des keys in allYamlKeys vor dem betreffenden key\n(z.B. type) oder der davor (im Falle eines addRef) muss der key mit dem ref oder addRef sein.\n\nWenn nicht, darf der Pfad in allYamlKeys ja keine Punkte enthalten, sonst sollen die Completions nicht erscheinen.\nAuerdem muss der Pfad in uniqueDefs vertreten sein.\n\n*/\n","import {\n  Disposable,\n  Webview,\n  WebviewPanel,\n  window,\n  Uri,\n  ViewColumn,\n  commands,\n  ExtensionContext,\n} from \"vscode\";\nimport { getUri } from \"../utilities/webview\";\nimport { getNonce } from \"../utilities/webview\";\nimport { listGpkgFilesInDirectory, uploadedGpkg, setCancel } from \"../utilities/gpkg\";\nimport * as vscode from \"vscode\";\nimport { connect, TransportCreator, Xtracfg } from \"@xtracfg/core\";\nimport { getWorkspacePath, getWorkspaceUri } from \"../utilities/paths\";\nimport { Registration } from \"../utilities/registration\";\nimport { DEV } from \"../utilities/constants\";\nimport { type Transport } from \"..\";\n\nconst workspaceFolders = vscode.workspace.workspaceFolders;\nif (!workspaceFolders) {\n  throw new Error(\"No workspace folder...\");\n}\nconst watcherOnDidDelete = vscode.workspace.createFileSystemWatcher(\n  new vscode.RelativePattern(workspaceFolders[0], \"resources/features/**\")\n);\n\nconst watcherOnDidCreate = vscode.workspace.createFileSystemWatcher(\n  new vscode.RelativePattern(workspaceFolders[0], \"resources/features/**\")\n);\n\nconst workspaceUri = getWorkspaceUri();\nlet xtracfg: Xtracfg;\n\nexport const registerShowAutoCreate: Registration = (\n  context: ExtensionContext,\n  { transport, additionalTransportOptions }: Transport\n): Disposable[] => {\n  xtracfg = connect(transport, { specific: additionalTransportOptions, debug: DEV });\n\n  return [\n    commands.registerCommand(\"ldproxy-editor.showAutoCreate\", () => {\n      AutoCreatePanel.render(context.extensionUri);\n    }),\n  ];\n};\n\n/**\n * This class manages the state and behavior of HelloWorld webview panels.\n *\n * It contains all the data and methods for:\n *\n * - Creating and rendering HelloWorld webview panels\n * - Properly cleaning up and disposing of webview resources when the panel is closed\n * - Setting the HTML (and by proxy CSS/JavaScript) content of the webview panel\n * - Setting message listeners so data can be passed between the webview and extension\n */\nexport class AutoCreatePanel {\n  public static currentPanel: AutoCreatePanel | undefined;\n  private readonly _panel: WebviewPanel;\n  private readonly _extensionUri: Uri;\n  private _disposables: Disposable[] = [];\n\n  /**\n   * The HelloWorldPanel class private constructor (called only from the render method).\n   *\n   * @param panel A reference to the webview panel\n   * @param extensionUri The URI of the directory containing the extension\n   */\n  private constructor(panel: WebviewPanel, extensionUri: Uri) {\n    this._panel = panel;\n    this._extensionUri = extensionUri;\n\n    // Set an event listener to listen for when the panel is disposed (i.e. when the user closes\n    // the panel or when the panel is closed programmatically)\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    // Set the HTML content for the webview panel\n    this._panel.webview.html = this._getWebviewContent(this._panel.webview, extensionUri);\n\n    // Set an event listener to listen for messages passed from the webview context\n    this._setWebviewMessageListener(this._panel.webview);\n\n    watcherOnDidCreate.onDidCreate(async (e) => {\n      this._panel.webview.postMessage({\n        command: \"setGeopackages\",\n        existingGeopackages: await listGpkgFilesInDirectory(),\n      });\n    });\n    this._disposables.push(watcherOnDidCreate);\n\n    watcherOnDidDelete.onDidDelete(async (e) => {\n      this._panel.webview.postMessage({\n        command: \"setGeopackages\",\n        existingGeopackages: await listGpkgFilesInDirectory(),\n      });\n      this._panel.webview.postMessage({\n        command: \"selectedGeoPackageDeleted\",\n        deletedGpkg: e.fsPath,\n      });\n    });\n    this._disposables.push(watcherOnDidDelete);\n\n    xtracfg.listen(\n      async (response) => {\n        await this._panel.webview.postMessage({\n          command: \"xtracfg\",\n          response,\n        });\n      },\n      async (error) => {\n        await this._panel.webview.postMessage({\n          command: \"xtracfg\",\n          error,\n        });\n      }\n    );\n  }\n\n  /**\n   * Renders the current webview panel if it exists otherwise a new webview panel\n   * will be created and displayed.\n   *\n   * @param extensionUri The URI of the directory containing the extension.\n   */\n  public static render(extensionUri: Uri) {\n    if (AutoCreatePanel.currentPanel) {\n      // If the webview panel already exists reveal it\n      AutoCreatePanel.currentPanel._panel.reveal(ViewColumn.One);\n    } else {\n      // If a webview panel does not already exist create and show a new one\n      const panel = window.createWebviewPanel(\n        // Panel view type\n        \"ldproxy-editor.showAutoCreate\",\n        // Panel title\n        \"Create new entities\",\n        // The editor column the panel should be displayed in\n        ViewColumn.One,\n        // Extra panel configurations\n        {\n          // Enable JavaScript in the webview\n          enableScripts: true,\n          // Restrict the webview to only load resources from the `out` and `webview-ui/build` directories\n          localResourceRoots: [\n            Uri.joinPath(extensionUri, \"out\"),\n            Uri.joinPath(extensionUri, \"./webview-ui/build\"),\n          ],\n        }\n      );\n      AutoCreatePanel.currentPanel = new AutoCreatePanel(panel, extensionUri);\n    }\n  }\n\n  /**\n   * Cleans up and disposes of webview resources when the webview panel is closed.\n   */\n  public dispose() {\n    AutoCreatePanel.currentPanel = undefined;\n\n    xtracfg.disconnect();\n\n    // Dispose of the current webview panel\n    this._panel.dispose();\n\n    // Dispose of all disposables (i.e. commands) for the current webview panel\n    while (this._disposables.length) {\n      const disposable = this._disposables.pop();\n      if (disposable) {\n        disposable.dispose();\n      }\n    }\n  }\n\n  public reload() {\n    this._panel.webview.html = this._getWebviewContent(this._panel.webview, this._extensionUri);\n  }\n\n  /**\n   * Defines and returns the HTML that should be rendered within the webview panel.\n   *\n   * @remarks This is also the place where references to the React webview build files\n   * are created and inserted into the webview HTML.\n   *\n   * @param webview A reference to the extension webview\n   * @param extensionUri The URI of the directory containing the extension\n   * @returns A template string literal containing the HTML that should be\n   * rendered within the webview panel\n   */\n  private _getWebviewContent(webview: Webview, extensionUri: Uri) {\n    // The CSS file from the React build output\n    const stylesUri = getUri(webview, extensionUri, [\n      \".\",\n      \"webview-ui\",\n      \"build\",\n      \"assets\",\n      \"index.css\",\n    ]);\n    // The JS file from the React build output\n    const scriptUri = getUri(webview, extensionUri, [\n      \".\",\n      \"webview-ui\",\n      \"build\",\n      \"assets\",\n      \"index.js\",\n    ]);\n\n    const nonce = getNonce();\n\n    // Tip: Install the es6-string-html VS Code extension to enable code highlighting below\n    return /*html*/ `\n      <!DOCTYPE html>\n      <html lang=\"en\">\n        <head>\n          <meta charset=\"UTF-8\" />\n          <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n          <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}'; connect-src 'self' ws:;\">\n          <link rel=\"stylesheet\" type=\"text/css\" href=\"${stylesUri}\">\n          <title>Hello World</title>    \n        </head>\n        <body>\n          <div id=\"root\" data-create-values=\"false\"></div>\n          <script type=\"module\" nonce=\"${nonce}\" src=\"${scriptUri}\"></script>\n        </body>\n      </html>\n    `;\n  }\n\n  /**\n   * Sets up an event listener to listen for messages passed from the webview context and\n   * executes code based on the message that is recieved.\n   *\n   * @param webview A reference to the extension webview\n   * @param context A reference to the extension context\n   */\n\n  private _setWebviewMessageListener(webview: Webview) {\n    webview.onDidReceiveMessage(\n      async (message: any) => {\n        const command = message.command;\n        const text = message.text;\n\n        switch (command) {\n          case \"hello\":\n            // Code that should run in response to the hello message command\n            window.showInformationMessage(text);\n            break;\n          case \"error\":\n            window.showErrorMessage(text);\n            break;\n          case \"onLoad\":\n            this._panel.webview.postMessage({\n              command: \"setWorkspace\",\n              workspaceRoot: getWorkspacePath(),\n            });\n            break;\n          case \"setExistingGpkg\":\n            this._panel.webview.postMessage({\n              command: \"setGeopackages\",\n              existingGeopackages: await listGpkgFilesInDirectory(),\n            });\n            break;\n          case \"closeWebview\":\n            this.dispose();\n            break;\n          case \"reloadWebview\":\n            this.reload();\n            break;\n          case \"success\":\n            if (workspaceUri) {\n              const fileUri = workspaceUri.with({ path: text });\n              await vscode.commands.executeCommand(\"vscode.open\", fileUri, { preview: false });\n            }\n            break;\n          case \"uploadGpkg\":\n            this._panel.webview.postMessage({\n              command: \"uploadedGpkg\",\n              uploadedGpkg: await uploadedGpkg(text[0], text[1]),\n            });\n            break;\n          case \"cancelSavingGpkg\":\n            setCancel();\n            break;\n          case \"xtracfg\":\n            if (message.request) {\n              xtracfg.send(JSON.parse(message.request));\n            }\n            break;\n          case \"geoPackageWasUploaded\":\n            window.showInformationMessage(text);\n            break;\n          // Add more switch case statements here as more webview message commands\n          // are created within the webview context (i.e. inside media/main.js)\n        }\n      },\n      undefined,\n      this._disposables\n    );\n  }\n}\n","import {\n  Disposable,\n  Webview,\n  WebviewPanel,\n  window,\n  Uri,\n  ViewColumn,\n  commands,\n  ExtensionContext,\n} from \"vscode\";\nimport { getUri } from \"../utilities/webview\";\nimport { getNonce } from \"../utilities/webview\";\nimport * as vscode from \"vscode\";\nimport { connect, TransportCreator, Xtracfg } from \"@xtracfg/core\";\nimport { getWorkspacePath, getWorkspaceUri } from \"../utilities/paths\";\nimport { Registration } from \"../utilities/registration\";\nimport { listApisInDirectory } from \"../utilities/apis\";\nimport { DEV } from \"../utilities/constants\";\nimport { type Transport } from \"..\";\n\nconst workspaceFolders = vscode.workspace.workspaceFolders;\nif (!workspaceFolders) {\n  throw new Error(\"No workspace folder...\");\n}\n\nconst workspaceUri = getWorkspaceUri();\nlet xtracfg: Xtracfg;\n\nexport const registerShowAutoCreateValues: Registration = (\n  context: ExtensionContext,\n  { transport, additionalTransportOptions }: Transport\n): Disposable[] => {\n  xtracfg = connect(transport, { specific: additionalTransportOptions, debug: DEV });\n\n  return [\n    commands.registerCommand(\"ldproxy-editor.showAutoCreateValues\", () => {\n      AutoCreateValuesPanel.render(context.extensionUri);\n    }),\n  ];\n};\n\n/**\n * This class manages the state and behavior of HelloWorld webview panels.\n *\n * It contains all the data and methods for:\n *\n * - Creating and rendering HelloWorld webview panels\n * - Properly cleaning up and disposing of webview resources when the panel is closed\n * - Setting the HTML (and by proxy CSS/JavaScript) content of the webview panel\n * - Setting message listeners so data can be passed between the webview and extension\n */\nexport class AutoCreateValuesPanel {\n  public static currentPanel: AutoCreateValuesPanel | undefined;\n  private readonly _panel: WebviewPanel;\n  private readonly _extensionUri: Uri;\n  private _disposables: Disposable[] = [];\n\n  /**\n   * The HelloWorldPanel class private constructor (called only from the render method).\n   *\n   * @param panel A reference to the webview panel\n   * @param extensionUri The URI of the directory containing the extension\n   */\n  private constructor(panel: WebviewPanel, extensionUri: Uri) {\n    this._panel = panel;\n    this._extensionUri = extensionUri;\n\n    // Set an event listener to listen for when the panel is disposed (i.e. when the user closes\n    // the panel or when the panel is closed programmatically)\n    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n\n    // Set the HTML content for the webview panel\n    this._panel.webview.html = this._getWebviewContent(this._panel.webview, extensionUri);\n\n    // Set an event listener to listen for messages passed from the webview context\n    this._setWebviewMessageListener(this._panel.webview);\n\n    xtracfg.listen(\n      async (response) => {\n        await this._panel.webview.postMessage({\n          command: \"xtracfg\",\n          response,\n        });\n      },\n      async (error) => {\n        await this._panel.webview.postMessage({\n          command: \"xtracfg\",\n          error,\n        });\n      }\n    );\n  }\n\n  /**\n   * Renders the current webview panel if it exists otherwise a new webview panel\n   * will be created and displayed.\n   *\n   * @param extensionUri The URI of the directory containing the extension.\n   */\n  public static render(extensionUri: Uri) {\n    if (AutoCreateValuesPanel.currentPanel) {\n      // If the webview panel already exists reveal it\n      AutoCreateValuesPanel.currentPanel._panel.reveal(ViewColumn.One);\n    } else {\n      // If a webview panel does not already exist create and show a new one\n      const panel = window.createWebviewPanel(\n        // Panel view type\n        \"ldproxy-editor.showAutoCreateValues\",\n        // Panel title\n        \"Create new values\",\n        // The editor column the panel should be displayed in\n        ViewColumn.One,\n        // Extra panel configurations\n        {\n          // Enable JavaScript in the webview\n          enableScripts: true,\n          // Restrict the webview to only load resources from the `out` and `webview-ui/build` directories\n          localResourceRoots: [\n            Uri.joinPath(extensionUri, \"out\"),\n            Uri.joinPath(extensionUri, \"./webview-ui/build\"),\n          ],\n        }\n      );\n      AutoCreateValuesPanel.currentPanel = new AutoCreateValuesPanel(panel, extensionUri);\n    }\n  }\n\n  /**\n   * Cleans up and disposes of webview resources when the webview panel is closed.\n   */\n  public dispose() {\n    AutoCreateValuesPanel.currentPanel = undefined;\n\n    xtracfg.disconnect();\n\n    // Dispose of the current webview panel\n    this._panel.dispose();\n\n    // Dispose of all disposables (i.e. commands) for the current webview panel\n    while (this._disposables.length) {\n      const disposable = this._disposables.pop();\n      if (disposable) {\n        disposable.dispose();\n      }\n    }\n  }\n\n  public reload() {\n    this._panel.webview.html = this._getWebviewContent(this._panel.webview, this._extensionUri);\n  }\n\n  /**\n   * Defines and returns the HTML that should be rendered within the webview panel.\n   *\n   * @remarks This is also the place where references to the React webview build files\n   * are created and inserted into the webview HTML.\n   *\n   * @param webview A reference to the extension webview\n   * @param extensionUri The URI of the directory containing the extension\n   * @returns A template string literal containing the HTML that should be\n   * rendered within the webview panel\n   */\n  private _getWebviewContent(webview: Webview, extensionUri: Uri) {\n    // The CSS file from the React build output\n    const stylesUri = getUri(webview, extensionUri, [\n      \".\",\n      \"webview-ui\",\n      \"build\",\n      \"assets\",\n      \"index.css\",\n    ]);\n    // The JS file from the React build output\n    const scriptUri = getUri(webview, extensionUri, [\n      \".\",\n      \"webview-ui\",\n      \"build\",\n      \"assets\",\n      \"index.js\",\n    ]);\n\n    const nonce = getNonce();\n\n    // Tip: Install the es6-string-html VS Code extension to enable code highlighting below\n    return /*html*/ `\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"UTF-8\" />\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n            <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src ${webview.cspSource}; script-src 'nonce-${nonce}'; connect-src 'self' ws:;\">\n            <link rel=\"stylesheet\" type=\"text/css\" href=\"${stylesUri}\">\n            <title>Hello World</title>    \n          </head>\n          <body>\n            <div id=\"root\" data-create-values=\"true\"></div>\n            <script type=\"module\" nonce=\"${nonce}\" src=\"${scriptUri}\"></script>\n          </body>\n        </html>\n      `;\n  }\n\n  /**\n   * Sets up an event listener to listen for messages passed from the webview context and\n   * executes code based on the message that is recieved.\n   *\n   * @param webview A reference to the extension webview\n   * @param context A reference to the extension context\n   */\n\n  private _setWebviewMessageListener(webview: Webview) {\n    webview.onDidReceiveMessage(\n      async (message: any) => {\n        const command = message.command;\n        const text = message.text;\n\n        switch (command) {\n          case \"hello\":\n            // Code that should run in response to the hello message command\n            window.showInformationMessage(text);\n            break;\n          case \"error\":\n            window.showErrorMessage(text);\n            break;\n          case \"onLoad\":\n            this._panel.webview.postMessage({\n              command: \"setWorkspace\",\n              workspaceRoot: getWorkspacePath(),\n            });\n            break;\n          case \"closeWebview\":\n            this.dispose();\n            break;\n          case \"reloadWebview\":\n            this.reload();\n            break;\n          case \"success\":\n            if (workspaceUri) {\n              const fileUri = workspaceUri.with({ path: text });\n              await vscode.commands.executeCommand(\"vscode.open\", fileUri, { preview: false });\n            }\n            break;\n          case \"xtracfg\":\n            if (message.request) {\n              xtracfg.send(JSON.parse(message.request));\n            }\n            break;\n          case \"setExistingApis\":\n            this._panel.webview.postMessage({\n              command: \"setApis\",\n              existingApis: await listApisInDirectory(),\n            });\n            break;\n          // Add more switch case statements here as more webview message commands\n          // are created within the webview context (i.e. inside media/main.js)\n        }\n      },\n      undefined,\n      this._disposables\n    );\n  }\n}\n","import { window } from \"vscode\";\nimport { Registration } from \"../utilities/registration\";\nimport { SourcesProvider } from \"./SourcesProvider\";\nimport { EntitiesProvider } from \"./EntitiesProvider\";\n\nexport const registeTreeViews: Registration = () => {\n  return [\n    //window.registerTreeDataProvider(\"ldproxy-editor.storeTree\", new SourcesProvider()),\n    //window.registerTreeDataProvider(\"ldproxy-editor.entityTree\", new EntitiesProvider()),\n  ];\n};\n\n/* contribution points for tree views\n    \"views\": {\n      \"explorer\": [\n        {\n          \"id\": \"ldproxy-editor.storeTree\",\n          \"name\": \"Sources\"\n        },\n        {\n          \"id\": \"ldproxy-editor.entityTree\",\n          \"name\": \"Entities\"\n        }\n      ]\n    },\n    \"menus\": {\n      \"view/title\": [\n        {\n          \"when\": \"view == ldproxy-editor.storeTree\",\n          \"command\": \"ldproxy-editor.showAutoCreate\",\n          \"group\": \"navigation\"\n        }\n      ],\n      \"view/item/context\": [\n        {\n          \"when\": \"view == ldproxy-editor.storeTree && viewItem == folder\",\n          \"command\": \"ldproxy-editor.showAutoCreate\",\n          \"group\": \"inline\"\n        }\n      ]\n    }\n */\n","import * as path from \"path\";\nimport * as vscode from \"vscode\";\n\nlet cancel = false;\nexport const setCancel = () => {\n  cancel = true;\n};\n\n/**\n * @returns all APIs in a given services directory\n */\nexport async function listApisInDirectory() {\n  const workspaceFolders = vscode.workspace.workspaceFolders;\n\n  if (!workspaceFolders || workspaceFolders.length <= 0) {\n    return [\"No workspace folder...\"];\n  }\n\n  try {\n    const directoryUri = vscode.Uri.joinPath(workspaceFolders[0].uri, \"entities/instances\");\n    const directoryPath = path.posix.normalize(directoryUri.path);\n\n    const allFiles = await readAllFilesInDirectory(directoryUri);\n\n    const serviceFiles: string[] = allFiles.filter((file: string) => {\n      const relativePath = path.posix.relative(directoryPath, file);\n      const pathParts = relativePath.split(\"/\");\n\n      const hasServicesBeforeLastPart = pathParts.slice(0, -1).includes(\"services\");\n      const doesNotContainDefaults = !relativePath.includes(\"defaults\");\n\n      return hasServicesBeforeLastPart && doesNotContainDefaults;\n    });\n\n    const ymlFiles = serviceFiles.filter((file: string) => file.endsWith(\".yml\"));\n\n    return ymlFiles.map((file: string) => {\n      const baseName = path.posix.basename(file);\n      const nameWithoutExtension = path.parse(baseName).name;\n      return nameWithoutExtension;\n    });\n  } catch (error) {\n    return null;\n  }\n}\n\nasync function readAllFilesInDirectory(directoryUri: any) {\n  const files = await vscode.workspace.fs.readDirectory(directoryUri);\n  let allFiles: string[] = [];\n\n  for (const file of files) {\n    const fileUri = vscode.Uri.joinPath(directoryUri, file[0]);\n\n    if (file[1] === vscode.FileType.File) {\n      allFiles.push(fileUri.path);\n    } else if (file[1] === vscode.FileType.Directory) {\n      const subDirectoryFiles = await readAllFilesInDirectory(fileUri);\n      allFiles = allFiles.concat(subDirectoryFiles);\n    }\n  }\n  return allFiles;\n}\n","import * as vscode from \"vscode\";\nimport { getIndentation, indentationOfYamlObjectAboveCursor } from \"./yaml\";\n\ninterface YamlKey {\n  path: string;\n  index: number;\n  lineOfPath: number;\n  startOfArray?: number;\n  arrayIndex?: number;\n}\n\nexport const gatherInformation = (\n  position: vscode.Position,\n  document: vscode.TextDocument,\n  allYamlKeys: any\n) => {\n  const line = position.line + 1;\n  const column = position.character;\n\n  // When a few letters of the key are already typed when hitting auto completion\n  const textBeforeCursor: string = document\n    .lineAt(position.line)\n    .text.substring(0, position.character);\n  const lineText: string = document.lineAt(position.line).text;\n  const indentation: number = lineText.search(/\\S|$/);\n  const textBeforeCursorLength: number = textBeforeCursor.trim().length;\n\n  const text = document.getText();\n  const lines = text.split(\"\\n\");\n  const currentLine = lines[line - 1];\n  const pathAtCursor = currentLine.includes(\":\")\n    ? undefined\n    : textBeforeCursor.trim() !== \"\"\n    ? getPathAtCursor(allYamlKeys, line - 1, indentation)\n    : getPathAtCursor(allYamlKeys, line, column);\n\n  // Only show Completions when the Cursor has exactly the correct indentation\n  const indentationUsedInYaml = getIndentation(document.getText());\n  const indentationOfpathAtCursor = indentationOfYamlObjectAboveCursor(\n    allYamlKeys,\n    line,\n    pathAtCursor\n  );\n\n  return {\n    textBeforeCursor,\n    textBeforeCursorLength,\n    indentation,\n    indentationOfpathAtCursor,\n    line,\n    column,\n    indentationUsedInYaml,\n    pathAtCursor,\n  };\n};\n\nexport function getPathAtCursor(allYamlKeys: YamlKey[], line: number, column: number): string {\n  // Wenn textBeforeCursor existiert, muss in getPathAtCursor nicht von der Einrckung des Cursors,\n  // sondern vom ersten Buchstaben des Wortes ausgegangen werden. AUerdem muss line - 1 gerechnet werden.\n  // Also werden einfach andere parameter reingegeben.\n\n  if (allYamlKeys.length === 0) {\n    return \"\";\n  }\n\n  let indexToUse = Math.min(line, allYamlKeys.length - 1);\n\n  function getPathAtCursorString(\n    indexToUse: number,\n    column: number,\n    allYamlKeys: YamlKey[]\n  ): string {\n    let foundObj = allYamlKeys.find((obj) => obj.lineOfPath === line);\n    while (!foundObj && line > 0) {\n      line--;\n      foundObj = allYamlKeys.find((obj) => obj.lineOfPath === line);\n    }\n\n    if (foundObj) {\n      indexToUse = allYamlKeys.indexOf(foundObj);\n    }\n\n    for (let i = indexToUse; i >= 0; i--) {\n      const obj = allYamlKeys[i];\n      if (obj.index !== null && obj.index < column) {\n        return obj.path;\n      }\n    }\n    return \"\";\n  }\n\n  return column > 0 ? getPathAtCursorString(indexToUse, column, allYamlKeys) : \"\";\n}\n\nexport function shouldFilterExistingCharacters(\n  textBeforeCursor: string,\n  finalValue: string\n): boolean {\n  if (textBeforeCursor.trim() !== \"\") {\n    if (textBeforeCursor.trim().includes(\"-\")) {\n      const textWithoutHyphen = textBeforeCursor.trim().replace(\"-\", \"\");\n      return finalValue.startsWith(textWithoutHyphen.trim());\n    } else {\n      return finalValue.startsWith(textBeforeCursor.trim());\n    }\n  }\n  return true;\n}\n\nexport function createCompletionItem(\n  finalValue: string,\n  obj2: any,\n  enumArray: any[],\n  DEV: boolean\n): vscode.CompletionItem {\n  const completion = new vscode.CompletionItem(finalValue);\n  if (obj2.type && obj2.type === \"object\") {\n    completion.insertText = `${finalValue}: \\n  `;\n  } else if (obj2.type && obj2.type === \"array\") {\n    completion.insertText = `${finalValue}: \\n  - `;\n  } else {\n    completion.insertText = `${finalValue}: `;\n  }\n  completion.kind = vscode.CompletionItemKind.Method;\n  if (\n    enumArray.length > 0 &&\n    enumArray.some((enumItem) => {\n      return (\n        obj2.title === enumItem.key &&\n        (obj2.groupname === enumItem.groupname ||\n          (obj2.groupname === \"_TOP_LEVEL_\" && enumItem.groupname === \"\"))\n      );\n    })\n  ) {\n    completion.detail = \"Enum\";\n  } else if (obj2.type === \"object\" && obj2.ref !== \"\") {\n    completion.detail = \"obj\";\n  } else if (obj2.type === \"array\" && obj2.ref !== \"\") {\n    completion.detail = \"array\";\n  }\n\n  if (obj2.description !== \"\") {\n    completion.documentation = new vscode.MarkdownString(obj2.description);\n  }\n\n  if (\n    completion.detail === \"Enum\" ||\n    completion.detail === \"obj\" ||\n    completion.detail === \"array\"\n  ) {\n    completion.command = {\n      title: \"Trigger Suggest\",\n      command: \"editor.action.triggerSuggest\",\n    };\n  }\n\n  if (DEV) {\n    console.log(\"completion1\", finalValue);\n    console.log(\"insertText1\", completion.insertText);\n  }\n\n  return completion;\n}\n","import * as vscode from \"vscode\";\nimport { DefinitionsMap } from \"./defs\";\nimport { shouldFilterExistingCharacters, createCompletionItem } from \"./completions\";\n\ninterface YamlKey {\n  path: string;\n  index: number;\n  lineOfPath: number;\n  startOfArray?: number;\n  arrayIndex?: number;\n}\n\nexport function shouldShowCompletionsProv1(\n  textBeforeCursor: string,\n  column: number,\n  indentationOfpathAtCursor: number,\n  indentationUsedInYaml: number,\n  textBeforeCursorLength: number,\n  currentStartOfArray: number | undefined\n): boolean {\n  return isCompletionValid(\n    textBeforeCursor,\n    column,\n    indentationOfpathAtCursor,\n    indentationUsedInYaml,\n    textBeforeCursorLength,\n    currentStartOfArray\n  );\n}\n\nfunction isCompletionValid(\n  textBeforeCursor: string,\n  column: number,\n  indentationOfpathAtCursor: number,\n  indentationUsedInYaml: number,\n  textBeforeCursorLength: number,\n  currentStartOfArray: number | undefined\n): boolean {\n  /* Summary if-statement: only show completions when \n    1. there are no characters in the line typed yet, it's an Array, and the Cursor is e.g. 4 places more indented than the start of the property with the ref (in the case of standardYamlIndentation = 2) \n    2. Same case if we are not in an Array. -> 2 indentations less.\n    3. Certain characters of key already typed, Array, Cursor has to be 4 places more indented than the start of the property with the ref (in the case of standardYamlIndentation = 2) + the length of the characters already typed.\n    4. e.g. buildingBlock but only \"-\" typed yet (whitespace between hyphen and \"b\" has to be considered).\n    5. Same as Case 4 but some letters of e.g. buildingBlock already typed.\n    6. Same as case 3 if we are not in an Array. -> 2 indentations less than in example above.\n    */\n\n  return (\n    (textBeforeCursor.trim() === \"\" &&\n      currentStartOfArray &&\n      (column === indentationOfpathAtCursor + indentationUsedInYaml * 1 ||\n        column === indentationOfpathAtCursor + indentationUsedInYaml * 2)) ||\n    (textBeforeCursor.trim() === \"\" &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      !textBeforeCursor.trim().includes(\"-\") &&\n      currentStartOfArray &&\n      (column === indentationOfpathAtCursor + indentationUsedInYaml * 1 + textBeforeCursorLength ||\n        column ===\n          indentationOfpathAtCursor + indentationUsedInYaml * 2 + textBeforeCursorLength)) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() === \"-\" &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength + 1) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() !== \"-\" &&\n      textBeforeCursor.trim().includes(\"-\") &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      !textBeforeCursor.trim().includes(\"-\") &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength)\n  );\n}\n\nexport function getRefCompletionsProv1(\n  pathAtCursor: string | undefined,\n  currentStartOfArray: number | undefined,\n  textBeforeCursor: string,\n  definitionsMap: DefinitionsMap,\n  DEV: boolean,\n  allYamlKeys: YamlKey[],\n  enumArray: any[]\n): vscode.CompletionItem[] {\n  const refCompletions: vscode.CompletionItem[] = [];\n  for (const key in definitionsMap) {\n    if (definitionsMap.hasOwnProperty(key)) {\n      const obj = definitionsMap[key];\n      if (obj.ref !== \"\") {\n        const title = obj.title;\n        const value = obj.ref;\n        if (\n          title !== undefined &&\n          value !== undefined &&\n          pathAtCursor !== undefined &&\n          pathAtCursor.endsWith(title)\n        ) {\n          addRefCompletions(\n            refCompletions,\n            title,\n            value,\n            pathAtCursor,\n            currentStartOfArray,\n            textBeforeCursor,\n            definitionsMap,\n            DEV,\n            allYamlKeys,\n            enumArray\n          );\n        }\n      }\n    }\n  }\n  return refCompletions;\n}\n\nfunction addRefCompletions(\n  refCompletions: vscode.CompletionItem[],\n  title: string,\n  value: string,\n  pathAtCursor: string,\n  currentStartOfArray: number | undefined,\n  textBeforeCursor: string,\n  definitionsMap: DefinitionsMap,\n  DEV: boolean,\n  allYamlKeys: YamlKey[],\n  enumArray: any[]\n) {\n  for (const key2 in definitionsMap) {\n    if (definitionsMap.hasOwnProperty(key2)) {\n      const obj2 = definitionsMap[key2];\n      if (obj2.groupname === value) {\n        const finalValue = obj2.title;\n        if (DEV) {\n          console.log(\"allYamlKeys: \", allYamlKeys);\n          console.log(\"finalValueProv1\", finalValue);\n        }\n        if (\n          finalValue &&\n          isValidCompletion(finalValue, obj2, allYamlKeys, currentStartOfArray, title, pathAtCursor)\n        ) {\n          const completion = createCompletionItem(finalValue, obj2, enumArray, DEV);\n          const filterExistingCharacters = shouldFilterExistingCharacters(\n            textBeforeCursor,\n            finalValue\n          );\n          const existing = refCompletions.find((existingComp) => existingComp.label === finalValue);\n          if (filterExistingCharacters && existing === undefined) {\n            refCompletions.push(completion);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction isValidCompletion(\n  finalValue: string | undefined,\n  obj2: any,\n  allYamlKeys: YamlKey[],\n  currentStartOfArray: number | undefined,\n  title: string,\n  pathAtCursor: string\n): boolean {\n  return (\n    finalValue !== undefined &&\n    obj2.deprecated !== true &&\n    allYamlKeys &&\n    !allYamlKeys.some((key) => {\n      if (\n        key.hasOwnProperty(\"startOfArray\") &&\n        key.startOfArray === currentStartOfArray &&\n        key.path.includes(`${title}.${finalValue}`)\n      ) {\n        return true;\n      } else if (key.hasOwnProperty(\"startOfArray\")) {\n        return false;\n      } else {\n        return key.path === `${pathAtCursor}.${finalValue}`;\n      }\n    })\n  );\n}\n","export function shouldShowCompletionsProv2(\n  pathAtCursor: string | undefined,\n  textBeforeCursor: string,\n  column: number,\n  indentationOfpathAtCursor: number,\n  indentationUsedInYaml: number,\n  textBeforeCursorLength: number\n): boolean {\n  // For explanation of if-statement see ./completionsProv1.ts/isCompletionValid\n\n  return (\n    (pathAtCursor &&\n      pathAtCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() === \"\" &&\n      (column === indentationOfpathAtCursor + indentationUsedInYaml * 1 ||\n        column === indentationOfpathAtCursor + indentationUsedInYaml * 2)) ||\n    (pathAtCursor &&\n      pathAtCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() !== \"\" &&\n      !textBeforeCursor.trim().includes(\"-\") &&\n      (column === indentationOfpathAtCursor + indentationUsedInYaml * 1 + textBeforeCursorLength ||\n        column ===\n          indentationOfpathAtCursor + indentationUsedInYaml * 2 + textBeforeCursorLength)) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() === \"-\" &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength + 1) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() !== \"-\" &&\n      textBeforeCursor.trim().includes(\"-\") &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength)\n  );\n}\n","import * as vscode from \"vscode\";\n\nexport function shouldShowCompletionsProv3(\n  textBeforeCursor: string,\n  arrayIndex: number | undefined,\n  column: number,\n  indentationOfpathAtCursor: number,\n  indentationUsedInYaml: number,\n  textBeforeCursorLength: number\n): boolean {\n  return (\n    (textBeforeCursor.trim() === \"\" &&\n      arrayIndex !== -1 &&\n      (column === indentationOfpathAtCursor + indentationUsedInYaml * 1 ||\n        column === indentationOfpathAtCursor + indentationUsedInYaml * 2)) ||\n    (textBeforeCursor.trim() === \"\" &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      !textBeforeCursor.trim().includes(\"-\") &&\n      arrayIndex !== -1 &&\n      (column === indentationOfpathAtCursor + indentationUsedInYaml * 1 + textBeforeCursorLength ||\n        column ===\n          indentationOfpathAtCursor + indentationUsedInYaml * 2 + textBeforeCursorLength)) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() === \"-\" &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength + 1) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      textBeforeCursor.trim() !== \"-\" &&\n      textBeforeCursor.trim().includes(\"-\") &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength) ||\n    (textBeforeCursor.trim() !== \"\" &&\n      !textBeforeCursor.trim().includes(\"-\") &&\n      column === indentationOfpathAtCursor + indentationUsedInYaml + textBeforeCursorLength)\n  );\n}\n\nexport function createCompletionItemProv3(\n  value: string,\n  obj: any,\n  enumArray: any[],\n  DEV: boolean\n): vscode.CompletionItem {\n  const completion = new vscode.CompletionItem(value);\n  if (obj.type && obj.type === \"object\") {\n    completion.insertText = `${value}: \\n  `;\n  } else if (obj.type && obj.type === \"array\") {\n    completion.insertText = `${value}: \\n  - `;\n  } else {\n    completion.insertText = `${value}: `;\n  }\n  completion.kind = vscode.CompletionItemKind.Method;\n  if (\n    enumArray.length > 0 &&\n    enumArray.some((enumItem) => {\n      return (\n        obj.title === enumItem.key &&\n        (obj.groupname === enumItem.groupname ||\n          (obj.groupname === \"_TOP_LEVEL_\" && enumItem.groupname === \"\"))\n      );\n    })\n  ) {\n    completion.detail = \"Enum\";\n  } else if (obj.type === \"object\" && obj.ref !== \"\") {\n    completion.detail = \"obj\";\n  } else if (obj.type === \"array\" && obj.ref !== \"\") {\n    completion.detail = \"array\";\n  }\n\n  if (obj.description !== \"\") {\n    completion.documentation = new vscode.MarkdownString(obj.description);\n  }\n\n  if (DEV) {\n    console.log(\"completion21\", value);\n    console.log(\"insertText21\", completion.insertText);\n  }\n\n  return completion;\n}\n","export const DEV = true; //process.env.NODE_ENV === \"development\";\n\nexport const DEVYAMLKEYS = false;\n","import { DEV } from \"./constants\";\n\nexport interface LooseDefinition {\n  title?: string;\n  description?: string;\n  [key: string]: any;\n}\n\nexport interface DefinitionsMap {\n  [key: string]: LooseDefinition;\n}\n\nlet allMaps: {\n  [docUri: string]: { hash: string; definitionsMap: DefinitionsMap };\n} = {};\n\nexport function getDefinitionsMap(\n  schema: DefinitionsMap,\n  specifiedDefs: { ref: string; finalPath: string }[],\n  docUri?: string,\n  docHash?: string\n): DefinitionsMap {\n  if (docUri && docHash && allMaps[docUri] && allMaps[docUri].hash === docHash) {\n    if (DEV) {\n      console.log(\"allMapsDefMap\", allMaps);\n    }\n    return allMaps[docUri].definitionsMap;\n  }\n\n  let schemaDefs: any;\n  if (schema) {\n    schemaDefs = schema.$defs;\n  }\n\n  if (!schemaDefs) {\n    return {};\n  }\n  let definitionsMap: DefinitionsMap = {};\n\n  let allRefs: string[] | undefined = [];\n  if (specifiedDefs && specifiedDefs.length > 0) {\n    specifiedDefs.forEach((def) => {\n      definitionsMap = processProperties(def.ref, schemaDefs, definitionsMap);\n    });\n    if (DEV) {\n      console.log(\"specifiedDefsDefMap\", definitionsMap);\n    }\n  }\n\n  if (schema) {\n    const requiredProperties = getRequiredProperties(schema);\n    if (DEV) {\n      console.log(\"rereq\", requiredProperties);\n    }\n\n    definitionsMap = {\n      ...definitionsMap,\n      ...requiredProperties,\n    };\n  }\n\n  if (definitionsMap && Object.keys(definitionsMap).length > 0) {\n    allRefs = findObjectsWithRef(definitionsMap, schemaDefs);\n    if (DEV) {\n      console.log(\"allRefsDefMap\", allRefs);\n    }\n  }\n\n  if (allRefs && allRefs.length > 0) {\n    allRefs.forEach((ref) => {\n      if (DEV) {\n        console.log(\"refDefMap\", ref);\n      }\n      definitionsMap = {\n        ...definitionsMap,\n        ...processProperties(ref, schemaDefs, definitionsMap),\n      };\n    });\n  }\n\n  if (docUri && docHash) {\n    allMaps[docUri] = { hash: docHash, definitionsMap: definitionsMap };\n  }\n  return definitionsMap;\n}\n\n//TODO: export only needed for tests\nexport function processProperties(\n  defs: string,\n  schemaDefs: DefinitionsMap,\n  definitionsMap: DefinitionsMap = {}\n) {\n  let lastPartValue = \"\";\n  let lastPartValueAddRed = \"\";\n  if (DEV) {\n    console.log(\"defs\", defs);\n  }\n\n  if (defs !== \"\") {\n    const definition = schemaDefs[defs];\n    if (definition && definition.properties && Object.keys(definition.properties).length > 0) {\n      for (const propKey in definition.properties) {\n        const propDefinition = definition.properties[propKey];\n        if (propDefinition.title || propDefinition.description) {\n          const reference = propDefinition.$ref;\n          if (reference && reference.length > 0 && reference !== undefined) {\n            const lastSlashIndex = reference.lastIndexOf(\"/\");\n            lastPartValue = reference.substring(lastSlashIndex + 1);\n          }\n\n          let propDefinitionType;\n          if (propDefinition && propDefinition.type && propDefinition.type === \"object\") {\n            propDefinitionType = \"object\";\n          }\n\n          let referenceInConditionLastPart;\n          if (\n            propDefinition &&\n            propDefinition.allOf &&\n            propDefinition.allOf[0] &&\n            propDefinition.allOf[0].then &&\n            propDefinition.allOf[0].then.items &&\n            propDefinition.allOf[0].then.items.$ref\n          ) {\n            if (\n              propDefinition.allOf[0].if &&\n              propDefinition.allOf[0].if.type &&\n              propDefinition.allOf[0].if.type === \"array\"\n            ) {\n              propDefinitionType = \"array\";\n            }\n            const ref = propDefinition.allOf[0].then.items.$ref;\n            if (ref && ref.length > 0 && ref !== undefined) {\n              const lastSlashIndex = ref.lastIndexOf(\"/\");\n              referenceInConditionLastPart = ref.substring(lastSlashIndex + 1);\n            }\n          }\n\n          const additionalReference =\n            propDefinition.additionalProperties && propDefinition.additionalProperties.$ref;\n          if (additionalReference && additionalReference.length > 0) {\n            const lastSlashIndex = additionalReference.lastIndexOf(\"/\");\n            lastPartValueAddRed = additionalReference.substring(lastSlashIndex + 1);\n          }\n\n          let additionalReferenceInConditionLastPart;\n          if (\n            propDefinition.additionalProperties &&\n            propDefinition.additionalProperties.allOf &&\n            propDefinition.additionalProperties.allOf[0] &&\n            propDefinition.additionalProperties.allOf[0].then &&\n            propDefinition.additionalProperties.allOf[0].then.items &&\n            propDefinition.additionalProperties.allOf[0].then.items.$ref\n          ) {\n            const ref = propDefinition.additionalProperties.allOf[0].then.items.$ref;\n            if (ref && ref.length > 0 && ref !== undefined) {\n              const lastSlashIndex = ref.lastIndexOf(\"/\");\n              additionalReferenceInConditionLastPart = ref.substring(lastSlashIndex + 1);\n            }\n          }\n\n          let uniqueKey = propKey;\n          let counter = 1;\n\n          while (\n            (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].groupname !== defs) ||\n            (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].title !== propDefinition.title)\n          ) {\n            uniqueKey = propKey + counter;\n            counter++;\n          }\n\n          (definitionsMap[uniqueKey] = {\n            groupname: defs,\n            title: propDefinition.title,\n            description: propDefinition.description,\n            ref:\n              lastPartValue !== \"\"\n                ? lastPartValue\n                : referenceInConditionLastPart\n                ? referenceInConditionLastPart\n                : \"\",\n            addRef:\n              lastPartValueAddRed !== \"\"\n                ? lastPartValueAddRed\n                : additionalReferenceInConditionLastPart\n                ? additionalReferenceInConditionLastPart\n                : \"\",\n            type: propDefinitionType,\n            deprecated: propDefinition.deprecated ? true : false,\n          }),\n            (lastPartValue = \"\");\n          lastPartValueAddRed = \"\";\n        }\n      }\n    } else if (definition && definition.hasOwnProperty(\"anyOf\")) {\n      definition.anyOf.forEach((anyOfItem: any) => {\n        for (const propKey in anyOfItem.properties) {\n          if (DEV) {\n            console.log(\"propDefinitionMy\", propKey);\n          }\n\n          let deprecatedProperty = false;\n          let uniqueKey = propKey;\n          let counter = 1;\n\n          while (\n            (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].groupname !== defs) ||\n            (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].title !== propKey)\n          ) {\n            deprecatedProperty = definitionsMap[uniqueKey].deprecated ? true : false;\n            uniqueKey = propKey + counter;\n            counter++;\n          }\n          if (DEV) {\n            console.log(\"MyUniqueKey\", uniqueKey);\n          }\n          definitionsMap[uniqueKey] = {\n            groupname: defs,\n            title: propKey,\n            deprecated: deprecatedProperty,\n          };\n        }\n      });\n    }\n  }\n  return definitionsMap;\n}\n\n//TODO: export only needed for tests\nexport function findObjectsWithRef(definitionsMap: DefinitionsMap, schemaDefs: any): string[] {\n  let lastPartValueArray: string[] = [];\n  let hasNewReferences = true;\n\n  while (hasNewReferences) {\n    hasNewReferences = false;\n\n    for (const key in definitionsMap) {\n      const obj = definitionsMap[key];\n\n      if (typeof obj === \"object\" && obj[\"ref\"] !== \"\") {\n        const value = obj.ref;\n        if (DEV) {\n          console.log(\"valueBuildDef\", value);\n        }\n        if (value) {\n          const lastSlashIndex = value.lastIndexOf(\"/\");\n          const lastPartValue: string = value.substring(lastSlashIndex + 1);\n\n          if (!lastPartValueArray.includes(lastPartValue)) {\n            lastPartValueArray.push(lastPartValue);\n            hasNewReferences = true;\n\n            let nestedDefinitionsMap;\n            if (schemaDefs) {\n              if (DEV) {\n                console.log(\"lastPartValue\", lastPartValue);\n              }\n              nestedDefinitionsMap = processProperties(lastPartValue, schemaDefs, definitionsMap);\n            }\n            definitionsMap = { ...definitionsMap, ...nestedDefinitionsMap };\n          }\n        }\n      }\n\n      if (typeof obj === \"object\" && obj[\"addRef\"] !== \"\") {\n        const value = obj.addRef;\n\n        if (value) {\n          const lastSlashIndex = value.lastIndexOf(\"/\");\n          const lastPartValue: string = value.substring(lastSlashIndex + 1);\n\n          if (!lastPartValueArray.includes(lastPartValue)) {\n            lastPartValueArray.push(lastPartValue);\n            hasNewReferences = true;\n\n            let nestedDefinitionsMap;\n            if (schemaDefs) {\n              nestedDefinitionsMap = processProperties(lastPartValue, schemaDefs, definitionsMap);\n            }\n            definitionsMap = { ...definitionsMap, ...nestedDefinitionsMap };\n          }\n        }\n      }\n    }\n  }\n  if (DEV) {\n    console.log(\"lastPartValueArray\", lastPartValueArray);\n  }\n  return lastPartValueArray;\n}\n\n//TODO: export only needed for tests\nexport function getRequiredProperties(schema: DefinitionsMap): DefinitionsMap {\n  let requiredProperties: string[] = [];\n  let definitionsMap: DefinitionsMap = {};\n  if (schema) {\n    if (DEV) {\n      console.log(\"gRPSchema\", schema);\n    }\n    const requiredPropertieObject = schema.properties;\n    if (requiredPropertieObject) {\n      requiredProperties = Object.keys(requiredPropertieObject);\n      requiredProperties.forEach((requiredProperty: string) => {\n        const prop = requiredPropertieObject[requiredProperty];\n        let lastSlashIndex;\n        if (prop.$ref) {\n          lastSlashIndex = prop.$ref.lastIndexOf(\"/\");\n        }\n\n        let propDefinitionType;\n        if (prop && prop.type && prop.type === \"object\") {\n          propDefinitionType = \"object\";\n        }\n\n        let lastPartValueAddRed = \"\";\n        let additionalReference = \"\";\n        if (prop.additionalProperties && prop.additionalProperties.$ref) {\n          additionalReference = prop.additionalProperties.$ref;\n        }\n        if (DEV) {\n          console.log(\"gRPadditionalReference\", additionalReference);\n        }\n        if (additionalReference && additionalReference.length > 0) {\n          const lastSlashIndex = additionalReference.lastIndexOf(\"/\");\n          lastPartValueAddRed = additionalReference.substring(lastSlashIndex + 1);\n        }\n        let uniqueKey = requiredProperty;\n        let counter = 1;\n\n        while (\n          (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].groupname !== schema.groupName) ||\n          (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].title !== requiredProperty)\n        ) {\n          if (DEV) {\n            console.log(\"???\");\n          }\n          uniqueKey = requiredProperty + counter;\n          counter++;\n        }\n\n        definitionsMap[uniqueKey] = {\n          title: requiredProperty,\n          description: prop.enum ? prop.enum.join(\", \") : prop.description,\n          groupname: schema.groupName || \"requiredProperty\",\n          noCondition: true,\n          deprecated: prop.deprecated ? true : false,\n          ref: prop.$ref ? prop.$ref.substring(lastSlashIndex + 1) : \"\",\n          addRef: lastPartValueAddRed !== \"\" ? lastPartValueAddRed : \"\",\n          type: propDefinitionType,\n        };\n      });\n    }\n\n    if (schema.anyOf) {\n      const anyOfArray = schema.anyOf;\n      anyOfArray.forEach((obj: { properties: any }) => {\n        if (obj.properties) {\n          Object.keys(obj.properties).forEach((requiredProperty: string) => {\n            const prop = obj.properties[requiredProperty];\n            let lastSlashIndex;\n            if (prop.$ref) {\n              lastSlashIndex = prop.$ref.lastIndexOf(\"/\");\n            }\n            let lastPartValueAddRed = \"\";\n            let additionalReference = \"\";\n            if (prop.additionalProperties && prop.additionalProperties.$ref) {\n              additionalReference = prop.additionalProperties.$ref;\n            }\n            if (additionalReference && additionalReference.length > 0) {\n              const lastSlashIndex = additionalReference.lastIndexOf(\"/\");\n              lastPartValueAddRed = additionalReference.substring(lastSlashIndex + 1);\n            }\n            let uniqueKey = requiredProperty;\n            let counter = 1;\n\n            while (\n              (definitionsMap[uniqueKey] &&\n                definitionsMap[uniqueKey].groupname !== schema.groupName) ||\n              (definitionsMap[uniqueKey] && definitionsMap[uniqueKey].title !== requiredProperty)\n            ) {\n              uniqueKey = requiredProperty + counter;\n              counter++;\n            }\n\n            definitionsMap[uniqueKey] = {\n              title: requiredProperty,\n              description: prop.enum ? prop.enum.join(\", \") : prop.description,\n              groupname: schema.groupName || \"requiredProperty\",\n              noCondition: true,\n              deprecated: prop.deprecated ? true : false,\n              ref: prop.$ref ? prop.$ref.substring(lastSlashIndex + 1) : \"\",\n              addRef: lastPartValueAddRed !== \"\" ? lastPartValueAddRed : \"\",\n            };\n          });\n        }\n      });\n    }\n  }\n  if (DEV) {\n    console.log(\"requiredPropsMap\", definitionsMap);\n  }\n  return definitionsMap;\n}\n","import { DEV } from \"./constants\";\n\nexport function buildEnumArray(\n  definitions: any\n): { key: string; enum: string; groupname: string | \"\" }[] {\n  let localEnumArray: { key: string; enum: string; groupname: string | \"\" }[] = [];\n  if (DEV) {\n    console.log(\"enumDefinitions\", definitions);\n  }\n\n  if (definitions.hasOwnProperty(\"properties\")) {\n    for (const key in definitions.properties) {\n      const definition = definitions.properties[key];\n      if (definition && definition.hasOwnProperty(\"enum\")) {\n        definition.enum.forEach((enumValue: string) => {\n          const existing = localEnumArray.find(\n            (existingEnum) =>\n              existingEnum.key === key &&\n              existingEnum.enum === enumValue &&\n              existingEnum.groupname === \"\"\n          );\n          if (existing === undefined) {\n            localEnumArray.push({ key: key, enum: enumValue, groupname: \"\" });\n          }\n        });\n      }\n    }\n  }\n  if (definitions.hasOwnProperty(\"anyOf\") && definitions.anyOf[0]) {\n    if (DEV) {\n      console.log(\"definitions.anyOf[0]\", definitions.anyOf[0]);\n    }\n    definitions.anyOf.forEach((item: any) => {\n      if (item.hasOwnProperty(\"properties\")) {\n        if (DEV) {\n          console.log(\"propItem\", item.properties);\n        }\n        for (const propKey in item.properties) {\n          const propDefinition = item.properties[propKey];\n          if (DEV) {\n            console.log(\"propDefinitiongetEnum\", propDefinition);\n          }\n          if (propDefinition && propDefinition.hasOwnProperty(\"enum\")) {\n            if (DEV) {\n              console.log(\"propDefinition.enum\", propDefinition.enum);\n            }\n            propDefinition.enum.forEach((enumValue: string) => {\n              const existing = localEnumArray.find(\n                (existingEnum) =>\n                  existingEnum.key === propKey &&\n                  existingEnum.enum === enumValue &&\n                  existingEnum.groupname === \"\"\n              );\n              if (existing === undefined) {\n                localEnumArray.push({ key: propKey, enum: enumValue, groupname: \"\" });\n              }\n            });\n          }\n        }\n      }\n    });\n  }\n\n  for (const key in definitions.$defs) {\n    const definition = definitions.$defs[key];\n\n    if (definition && definition.anyOf && definition.anyOf[0] && definition.anyOf[0].properties) {\n      definition.anyOf.forEach((item: any) => {\n        for (const propKey in item.properties) {\n          const propDefinition = item.properties[propKey];\n          if (propDefinition && propDefinition.hasOwnProperty(\"enum\")) {\n            propDefinition.enum.forEach((enumValue: string) => {\n              const existing = localEnumArray.find(\n                (existingEnum) =>\n                  existingEnum.key === propKey &&\n                  existingEnum.enum === enumValue &&\n                  existingEnum.groupname === key\n              );\n              if (existing === undefined) {\n                localEnumArray.push({ key: propKey, enum: enumValue, groupname: key });\n              }\n            });\n          }\n        }\n      });\n    } else if (definition && definition.properties) {\n      for (const propKey in definition.properties) {\n        const propDefinition = definition.properties[propKey];\n        if (propDefinition && propDefinition.hasOwnProperty(\"enum\")) {\n          propDefinition.enum.forEach((enumValue: string) => {\n            const existing = localEnumArray.find(\n              (existingEnum) =>\n                existingEnum.key === propKey &&\n                existingEnum.enum === enumValue &&\n                existingEnum.groupname === key\n            );\n            if (existing === undefined) {\n              localEnumArray.push({ key: propKey, enum: enumValue, groupname: key });\n            }\n          });\n        } else if (\n          propDefinition &&\n          propDefinition.hasOwnProperty(\"oneOf\") &&\n          propDefinition.hasOwnProperty(\"title\")\n        ) {\n          propDefinition.oneOf.forEach((obj: any) => {\n            if (obj && obj.hasOwnProperty(\"type\") && obj.type === \"boolean\") {\n              const existingWithTrue = localEnumArray.find(\n                (existingEnum) =>\n                  existingEnum.key === propDefinition.title &&\n                  existingEnum.enum === \"true\" &&\n                  existingEnum.groupname === key\n              );\n\n              const existingWithFalse = localEnumArray.find(\n                (existingEnum) =>\n                  existingEnum.key === propDefinition.title &&\n                  existingEnum.enum === \"false\" &&\n                  existingEnum.groupname === key\n              );\n\n              if (existingWithTrue === undefined && existingWithFalse === undefined) {\n                localEnumArray.push({ key: propDefinition.title, enum: \"true\", groupname: key });\n                localEnumArray.push({ key: propDefinition.title, enum: \"false\", groupname: key });\n              } else if (existingWithTrue === undefined) {\n                localEnumArray.push({ key: propDefinition.title, enum: \"true\", groupname: key });\n              } else if (existingWithFalse === undefined) {\n                localEnumArray.push({ key: propDefinition.title, enum: \"false\", groupname: key });\n              }\n            }\n          });\n        }\n      }\n    }\n  }\n  if (DEV) {\n    console.log(\"localEnumArray\", JSON.stringify(localEnumArray));\n  }\n  return localEnumArray;\n}\n","import * as path from \"path\";\nimport * as vscode from \"vscode\";\n\nconst atob = (input: string): string => Buffer.from(input, \"base64\").toString(\"binary\");\n\nlet cancel = false;\nexport const setCancel = () => {\n  cancel = true;\n};\n\n/**\n * @returns all .gpkg files in a given directory and its subdirectories\n */\nexport async function listGpkgFilesInDirectory() {\n  const workspaceFolders = vscode.workspace.workspaceFolders;\n\n  if (!workspaceFolders || workspaceFolders.length <= 0) {\n    return [\"No workspace folder...\"];\n  }\n\n  try {\n    const directoryUri = vscode.Uri.joinPath(workspaceFolders[0].uri, \"resources/features\");\n    const directoryPath = path.posix.normalize(directoryUri.path);\n\n    const allFiles = await readAllFilesInDirectory(directoryUri);\n\n    const gpkgFiles: string[] = allFiles.filter((file: string) => path.extname(file) === \".gpkg\");\n\n    return gpkgFiles.map((file: string) => path.posix.relative(directoryPath, file));\n  } catch (error) {\n    return [\"No Geopackages...\"];\n  }\n}\n\nasync function readAllFilesInDirectory(directoryUri: any) {\n  const files = await vscode.workspace.fs.readDirectory(directoryUri);\n  let allFiles: string[] = [];\n\n  for (const file of files) {\n    const fileUri = vscode.Uri.joinPath(directoryUri, file[0]);\n\n    if (file[1] === vscode.FileType.File) {\n      allFiles.push(fileUri.path);\n    } else if (file[1] === vscode.FileType.Directory) {\n      const subDirectoryFiles = await readAllFilesInDirectory(fileUri);\n      allFiles = allFiles.concat(subDirectoryFiles);\n    }\n  }\n  return allFiles;\n}\n\nexport async function uploadedGpkg(gpkgToUpload: any, filename: string) {\n  cancel = false;\n\n  const cancelPromise = new Promise((resolve, reject) => {\n    const intervalId = setInterval(() => {\n      if (cancel) {\n        clearInterval(intervalId);\n        reject(new Error(\"Operation was cancelled\"));\n      }\n    }, 2000);\n  });\n\n  const uploadPromise = (async () => {\n    const binaryString = atob(gpkgToUpload);\n\n    const uint8Array = new Uint8Array(binaryString.length);\n\n    for (let i = 0; i < binaryString.length; i++) {\n      uint8Array[i] = binaryString.charCodeAt(i);\n    }\n\n    const workspaceFolders = vscode.workspace.workspaceFolders;\n\n    if (workspaceFolders && workspaceFolders[0]) {\n      const directoryUri = vscode.Uri.joinPath(workspaceFolders[0].uri, \"resources/features\");\n\n      const filePath = vscode.Uri.joinPath(directoryUri, filename);\n\n      try {\n        await vscode.workspace.fs.createDirectory(directoryUri);\n        try {\n          await vscode.workspace.fs.stat(filePath);\n          return `Geopackage already exists.`;\n        } catch {\n          if (cancel) {\n            return;\n          }\n          await vscode.workspace.fs.writeFile(filePath, uint8Array);\n          return `Datei erfolgreich geschrieben: ${filePath.fsPath}`;\n        }\n      } catch (error) {\n        return `Error uploading Geopackage. ${error}`;\n      }\n    }\n  })();\n\n  try {\n    const result = await Promise.race([uploadPromise, cancelPromise]);\n    if (cancel) {\n      const directoryUri = vscode.Uri.joinPath(\n        vscode.workspace.workspaceFolders\n          ? vscode.workspace.workspaceFolders[0].uri\n          : vscode.Uri.file(\"\"),\n        \"resources/features\"\n      );\n      const filePath = vscode.Uri.joinPath(directoryUri, filename);\n      if (filePath) {\n        try {\n          await vscode.workspace.fs.stat(filePath);\n          await vscode.workspace.fs.delete(filePath);\n          //  await vscode.workspace.fs.delete(directoryUri, { recursive: true });\n        } catch (error) {\n          console.log(`File not created yet: ${filePath}`);\n        }\n      }\n    }\n    return result;\n  } finally {\n    cancel = false;\n  }\n}\n","import * as vscode from \"vscode\";\n\nexport const getWorkspacePath = (): string | undefined => {\n  const workspace = getWorkspaceUri();\n\n  if (workspace && workspace.fsPath) {\n    // workaround for docker + windows\n    if (workspace.fsPath.startsWith(\"\\\\\")) {\n      return getWorkspacePathNormalized();\n    }\n\n    return workspace.fsPath;\n  }\n\n  return undefined;\n};\n\nexport const getCurrentFilePath = (): string | undefined => {\n  const activeTextEditor = vscode.window.activeTextEditor;\n  const workspacePath = getWorkspacePathNormalized();\n\n  if (activeTextEditor && workspacePath) {\n    const path = activeTextEditor.document.uri.path;\n\n    if (path.startsWith(workspacePath)) {\n      return path.substring(workspacePath.length + 1);\n    }\n  }\n\n  return undefined;\n};\n\nexport const getRelativeFilePath = (uri: vscode.Uri): string | undefined => {\n  const workspacePath = getWorkspacePathNormalized();\n\n  if (uri && workspacePath) {\n    const path = uri.path;\n\n    if (path.startsWith(workspacePath)) {\n      return path.substring(workspacePath.length + 1);\n    }\n  }\n\n  return undefined;\n};\n\nexport const getWorkspaceUri = (): vscode.Uri | undefined => {\n  const workspaceFolders = vscode.workspace.workspaceFolders;\n\n  if (workspaceFolders && workspaceFolders[0]) {\n    return workspaceFolders[0].uri;\n  }\n\n  return undefined;\n};\n\nconst getWorkspacePathNormalized = (): string | undefined => {\n  const workspace = getWorkspaceUri();\n\n  return workspace ? workspace.path : undefined;\n};\n","import { DefinitionsMap } from \"./defs\";\nimport { LooseDefinition } from \"./defs\";\nimport { DEV } from \"./constants\";\nimport * as yaml from \"js-yaml\";\n\ninterface Conditions {\n  condition?: Record<string, any>;\n  ref?: string;\n}\n\nexport const TOP_LEVEL_REF = \"_TOP_LEVEL_\";\n\nfunction extractConditions(schema: LooseDefinition) {\n  if (!schema) {\n    return [];\n  }\n  const conditions: Conditions[] = [];\n\n  // berprfen, ob es ein allOf-Array in der obersten Ebene gibt\n  if (schema.allOf) {\n    for (const condition of schema.allOf) {\n      if (condition.if && condition.if.properties) {\n        const ref = condition.then?.$ref;\n        if (ref) {\n          conditions.push({\n            condition: condition.if.properties,\n            ref: ref.replace(\"#/$defs/\", \"\"),\n          });\n        }\n      }\n    }\n  }\n\n  if (schema.$defs) {\n    const defs = schema.$defs as DefinitionsMap;\n\n    for (const key in defs) {\n      if (defs.hasOwnProperty(key)) {\n        const def = defs[key];\n\n        if (def && def.allOf) {\n          for (const condition of def.allOf) {\n            if (condition.if && condition.if.properties) {\n              const ref = condition.then?.$ref;\n              if (ref) {\n                conditions.push({\n                  condition: condition.if.properties,\n                  ref: ref.replace(\"#/$defs/\", \"\"),\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  if (DEV) {\n    console.log(\"conditions\", conditions);\n  }\n  return conditions;\n}\n\nlet allSpecifiedDefs: {\n  [docUri: string]: { hash: string; specifiedDefs: { ref: string; finalPath: string }[] };\n} = {};\n\nexport function extractDocRefs(\n  documentGetText: string,\n  schema: LooseDefinition,\n  docUri?: string,\n  docHash?: string\n) {\n  if (docUri && docHash && allSpecifiedDefs[docUri] && allSpecifiedDefs[docUri].hash === docHash) {\n    return allSpecifiedDefs[docUri].specifiedDefs;\n  }\n\n  const config = yaml.load(documentGetText);\n  if (!config) {\n    return [];\n  }\n\n  const conditions = extractConditions(schema);\n\n  let specifiedDefs: { ref: string; finalPath: string }[] = [];\n\n  for (const { condition, ref } of conditions) {\n    if (condition) {\n      const resultObject = matchesCondition(config, condition);\n      if (DEV) {\n        console.log(\"returnObjects\", resultObject);\n      }\n      resultObject.forEach((item: { allConditionsMet: boolean; finalPath: string }) => {\n        if (DEV) {\n          console.log(\"item\", item);\n        }\n        const { allConditionsMet, finalPath } = item;\n        if (ref && allConditionsMet && finalPath !== \"\") {\n          if (DEV) {\n            console.log(\"allConditionsMet\", finalPath, allConditionsMet, ref);\n          }\n          specifiedDefs.push({ ref, finalPath });\n        }\n      });\n    }\n  }\n  //if (specifiedDefs.length === 0) {\n  specifiedDefs.push({ ref: TOP_LEVEL_REF, finalPath: \"\" });\n  //}\n  if (DEV) {\n    console.log(\"speecifiedDefs\", specifiedDefs);\n  }\n\n  if (docUri && docHash) {\n    allSpecifiedDefs[docUri] = { hash: docHash, specifiedDefs };\n  }\n\n  return specifiedDefs;\n}\n\nexport function matchesCondition(\n  config: LooseDefinition,\n  condition: Record<string, { const: string }>\n): { allConditionsMet: boolean; finalPath: string }[] {\n  let returnObjects: { allConditionsMet: boolean; finalPath: string }[] = [];\n  let allConditionsMet: boolean = true;\n\n  for (const key in condition) {\n    const conditionEntry = condition[key];\n    const conditionValue = conditionEntry?.const;\n    const lowerCasedConditionValue = conditionValue?.toLowerCase();\n\n    if (lowerCasedConditionValue !== undefined) {\n      const matchingPaths: string[] = [];\n\n      function getConfigValues(obj: any, targetKey: string, path: string): void {\n        if (typeof obj === \"object\") {\n          if (Array.isArray(obj)) {\n            for (let i = 0; i < obj.length; i++) {\n              const newPath = path ? `${path}.${targetKey}[${i}]` : `${targetKey}[${i}]`;\n              getConfigValues(obj[i], targetKey, newPath);\n            }\n          } else {\n            for (const currentKey in obj) {\n              const newPath = path ? `${path}.${currentKey}` : `${currentKey}`;\n              if (currentKey === targetKey) {\n                if (obj[currentKey].toLowerCase() === lowerCasedConditionValue) {\n                  matchingPaths.push(newPath);\n                }\n              }\n              getConfigValues(obj[currentKey], targetKey, newPath);\n            }\n          }\n        }\n      }\n\n      getConfigValues(config, key, \"\");\n\n      if (matchingPaths.length === 0) {\n        allConditionsMet = false;\n        break;\n      }\n\n      matchingPaths.forEach((path) => {\n        returnObjects.push({ allConditionsMet: true, finalPath: path });\n      });\n    }\n  }\n\n  if (!allConditionsMet) {\n    returnObjects = [{ allConditionsMet: false, finalPath: \"\" }];\n  }\n\n  return returnObjects;\n}\n\n// used for default configs so far\nexport function extractSingleRefs(\n  schema: LooseDefinition,\n  property?: string,\n  discriminatorKey?: string,\n  discriminatorValue?: string\n) {\n  let myRef: [{ ref: string; finalPath: string }] = [{ ref: \"\", finalPath: \"\" }];\n  const conditions = extractConditions(schema);\n  if (DEV) {\n    console.log(\"findMyRefconditions\", conditions);\n    console.log(\"findMyRefschema\", schema);\n    console.log(\"myProperty\", property);\n  }\n  if (!schema) {\n    return [];\n  }\n\n  if (discriminatorKey && discriminatorValue) {\n    if (DEV) {\n      console.log(\"findMyRefproperty\", discriminatorKey, discriminatorValue);\n    }\n    // case: discriminatorKey is in conditions (value of discriminatorKey is relevant choice of ref)\n    conditions.forEach((condition: { [key: string]: any }) => {\n      if (DEV) {\n        console.log(\"condition2\", condition);\n      }\n      const conditionKeys = Object.keys(condition.condition);\n      if (DEV) {\n        console.log(\"conditionKeys2\", conditionKeys);\n      }\n      if (conditionKeys.length === 1) {\n        conditionKeys.forEach((key: string) => {\n          if (DEV) {\n            console.log(\"blakey\", key);\n          }\n          if (key === discriminatorKey) {\n            if (DEV) {\n              console.log(\"condition.condition[key].const\", condition.condition[key].const);\n            }\n            if (condition.condition[key].const === discriminatorValue) {\n              if (DEV) {\n                console.log(\"condition.ref\", condition.ref);\n              }\n              const conditionRef = condition.ref;\n              myRef = [{ ref: conditionRef.replace(\"#/$defs/\", \"\"), finalPath: discriminatorKey }];\n            }\n          }\n        });\n      }\n    });\n  } else if (property) {\n    //case: just search property at top-level of schema and use the ref (property was not found in conditions)\n    // find only top-level defs:\n    let topLevelDefs = [];\n\n    if (schema && schema.allOf) {\n      for (const condition of schema.allOf) {\n        if (condition) {\n          const ref: string = condition.then?.$ref;\n          if (ref) {\n            topLevelDefs.push(ref.replace(\"#/$defs/\", \"\"));\n          }\n        }\n      }\n    }\n    if (DEV) {\n      console.log(\"topLevelDefs\", topLevelDefs);\n    }\n    if (topLevelDefs.length !== 0 && schema && schema.$defs) {\n      topLevelDefs.forEach((def: string) => {\n        const schemaDefs: DefinitionsMap = schema.$defs;\n        const definition = schemaDefs[def];\n        if (definition && definition.properties && Object.keys(definition.properties).length > 0) {\n          for (const propKey in definition.properties) {\n            const propDefinition = definition.properties[propKey];\n            if (propDefinition.title && propDefinition.title === property && propDefinition.$ref) {\n              const ref = propDefinition.$ref;\n              myRef = [{ ref: ref.replace(\"#/$defs/\", \"\"), finalPath: property }];\n            }\n          }\n        }\n      });\n    }\n  }\n  if (DEV) {\n    console.log(\"myRefDefault\", myRef);\n  }\n  return myRef;\n}\nexport function removeDuplicates(\n  specifiedDefs: { ref: string; finalPath: string }[]\n): { ref: string; finalPath: string }[] {\n  let uniquePaths: { ref: string; finalPath: string }[] = [];\n\n  specifiedDefs.forEach((def) => {\n    const { ref, finalPath } = def;\n    const refExists = uniquePaths.find((obj) => obj.ref === ref);\n    if (refExists) {\n      if (finalPath.includes(\".\")) {\n        uniquePaths.push({ ref, finalPath });\n      }\n    } else {\n      uniquePaths.push({ ref, finalPath });\n    }\n  });\n\n  return uniquePaths;\n}\n","import { Disposable, ExtensionContext, TextDocument } from \"vscode\";\nimport { AllYamlKeys } from \"./yaml\";\nimport { TransportCreator } from \"@xtracfg/core\";\nimport { type Transport } from \"..\";\n\nexport type Registration = (context: ExtensionContext, transport: Transport) => Disposable[];\n\nexport type DocUpdate = (\n  event: DocEvent,\n  document: TextDocument,\n  docUri: string,\n  docHash: string,\n  allYamlKeys: AllYamlKeys\n) => Promise<void>;\n\n/* eslint-disable @typescript-eslint/naming-convention*/\nexport enum DocEvent {\n  OPEN,\n  CHANGE,\n  SAVE,\n}\n/* eslint-enable @typescript-eslint/naming-convention*/\n\nexport const register = (\n  context: ExtensionContext,\n  transport: Transport,\n  ...registrations: Registration[]\n) => {\n  registrations.forEach((registration) =>\n    registration(context, transport).forEach((disposable) => context.subscriptions.push(disposable))\n  );\n};\n","import { connect, Xtracfg } from \"@xtracfg/core\";\nimport { getCurrentFilePath, getWorkspacePath } from \"./paths\";\nimport { DEV } from \"./constants\";\nimport { extractSingleRefs } from \"./refs\";\nimport { TOP_LEVEL_REF } from \"./refs\";\nimport { DefinitionsMap, LooseDefinition } from \"./defs\";\nimport { type Transport } from \"..\";\n\ninterface FileType {\n  type: string;\n  subProperty?: string;\n  discriminatorKey?: string;\n  discriminatorValue?: string;\n}\n\nlet xtracfg: Xtracfg;\nlet allSchemas: Promise<DefinitionsMap>;\n\nconst fileTypes: {\n  [key: string]: {\n    result: Promise<FileType>;\n    resolve: (fileType: FileType) => void;\n    reject: (reason: string) => void;\n  };\n} = {};\n\nexport const initSchemas = ({ transport, additionalTransportOptions }: Transport) => {\n  xtracfg = connect(transport, { specific: additionalTransportOptions, debug: DEV });\n\n  if (DEV) {\n    console.log(\"INIT SCHEMAS\");\n  }\n  let res: (value: DefinitionsMap) => void, rej;\n  allSchemas = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n\n  //TODO: reject on error\n  xtracfg.listen(\n    (response) => {\n      if (DEV) {\n        console.log(\"RESP\", response);\n      }\n      if (response.details && response.details.path && response.details.fileType) {\n        if (Object.hasOwn(fileTypes, response.details.path)) {\n          if (DEV) {\n            console.log(\"FOUND\");\n          }\n          const fileType: FileType = { type: response.details.fileType, ...response.details };\n          fileTypes[response.details.path].resolve(fileType);\n        }\n      } else if (\n        response.results &&\n        response.results[0] &&\n        response.results[0].message === \"schemas\" &&\n        response.details\n      ) {\n        let schemas: DefinitionsMap = {};\n\n        Object.keys(response.details).forEach((key) => {\n          if (response.details) {\n            schemas[key] = JSON.parse(response.details[key]);\n          }\n        });\n        if (DEV) {\n          console.log(\"SCHEMAS\", schemas);\n        }\n        res(schemas);\n      }\n    },\n    (error) => {\n      console.error(\"ERR\", error);\n    }\n  );\n\n  xtracfg.send({ command: \"schemas\", source: getWorkspacePath(), verbose: true, debug: true });\n};\n\nexport const getSchema = async (): Promise<LooseDefinition | undefined> => {\n  const schemas = await allSchemas;\n  const fileType = await getCurrentFileType();\n\n  if (!schemas || !fileType) {\n    return undefined;\n  }\n\n  const schema = schemas[fileType.type];\n  schema.groupName = TOP_LEVEL_REF;\n\n  if (DEV) {\n    console.log(\"FT\", fileType);\n  }\n\n  if (fileType.subProperty) {\n    const myRef = extractSingleRefs(\n      schema,\n      fileType.subProperty,\n      fileType?.discriminatorKey,\n      fileType?.discriminatorValue\n    );\n    const subSchema = {\n      ...schema.$defs[myRef[0].ref],\n      $defs: schema.$defs,\n      groupName: TOP_LEVEL_REF,\n    };\n    if (DEV) {\n      console.log(\"SUBSCHEMA\", subSchema, myRef[0].ref);\n    }\n    return subSchema;\n  }\n  if (DEV) {\n    console.log(\"schemaGetSchema\", schema);\n  }\n  return schema;\n};\n\nconst getCurrentFileType = async (): Promise<FileType | undefined> => {\n  const currentFilePath = getCurrentFilePath();\n\n  if (!currentFilePath) {\n    return undefined;\n  }\n\n  if (!Object.hasOwn(fileTypes, currentFilePath)) {\n    const fileType: any = {};\n    fileType.result = new Promise((resolve, reject) => {\n      fileType.resolve = resolve;\n      fileType.reject = reject;\n    });\n\n    fileTypes[currentFilePath] = fileType;\n\n    xtracfg.send({\n      command: \"file_type\",\n      source: getWorkspacePath(),\n      path: currentFilePath,\n      verbose: true,\n      debug: true,\n    });\n  }\n\n  return fileTypes[currentFilePath].result;\n};\n","import { Webview, Uri } from \"vscode\";\n\n/**\n * A helper function that returns a unique alphanumeric identifier called a nonce.\n *\n * @remarks This function is primarily used to help enforce content security\n * policies for resources/scripts being executed in a webview context.\n *\n * @returns A nonce\n */\nexport function getNonce() {\n  let text = \"\";\n  const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  for (let i = 0; i < 32; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n/**\n * A helper function which will get the webview URI of a given file or resource.\n *\n * @remarks This URI can be used within a webview's HTML as a link to the\n * given file/resource.\n *\n * @param webview A reference to the extension webview\n * @param extensionUri The URI of the directory containing the extension\n * @param pathList An array of strings representing the path to a file/resource\n * @returns A URI pointing to the file/resource\n */\n\nexport function getUri(webview: Webview, extensionUri: Uri, pathList: string[]) {\n  return webview.asWebviewUri(Uri.joinPath(extensionUri, ...pathList));\n}\n","import * as vscode from \"vscode\";\nimport { md5 } from \"js-md5\";\nimport { DEV, DEVYAMLKEYS } from \"./constants\";\nimport { Parser } from \"yaml\";\n\ninterface YamlKey {\n  path: string;\n  index: number;\n  lineOfPath: number;\n  startOfArray?: number;\n  arrayIndex?: number;\n}\n\nexport interface AllYamlKeys extends Array<YamlKey> {}\n\nexport function parseYaml(document: string) {\n  let allYamlKeys: AllYamlKeys = [];\n  const yamlObject: any[] = [];\n\n  for (const token of new Parser().parse(document)) {\n    if (DEVYAMLKEYS) {\n      console.log(\"token\", token);\n    }\n    yamlObject.push(token);\n  }\n\n  allYamlKeys = [];\n  allYamlKeys = getAllYamlPaths(document, yamlObject[0].value.items, \"\");\n  if (DEVYAMLKEYS) {\n    console.log(\"yamlKeysIndex\", allYamlKeys);\n  }\n  return allYamlKeys;\n}\n\nfunction getAllYamlPaths(\n  document: string,\n  yamlObject: any,\n  currentPath: string,\n  yamlKeys: {\n    path: string;\n    index: number;\n    lineOfPath: number;\n    startOfArray?: number;\n    arrayIndex?: number;\n  }[] = [],\n  arrayIndex: number = -1,\n  startOfArray?: number\n) {\n  if (yamlObject && typeof yamlObject === \"object\") {\n    if (DEVYAMLKEYS) {\n      console.log(\"yamlObjectgYK\", yamlObject);\n    }\n    //Fall: Array\n    yamlObject.forEach((object: any) => {\n      if (\n        object &&\n        object.key &&\n        object.key.source &&\n        object.value &&\n        object.value.items &&\n        object.value.items[0] &&\n        object.value.items[0].start[0] &&\n        object.value.items[0].start[0].source &&\n        object.value.items[0].value &&\n        object.value.items[0].value.items &&\n        object.value.items[0].value.items[0]\n      ) {\n        // Hier wird der erste Teil des Pfades (z.B. api) gebaut:\n        arrayIndex = -1;\n\n        const originalNewPath: string = object.key.source.replace(/\\./g, \"/\");\n        let newPath: string = originalNewPath;\n        let path: string = originalNewPath;\n        let line: number = getLineNumber(document, object.key.offset);\n        const column: number = object.key.indent;\n        if (line !== undefined && column !== undefined) {\n          // If there are illegitimate keys above our key (key without colon), then these aren't taken into account:\n          let lineIncrease = 0;\n          if (originalNewPath.includes(\"\\n\")) {\n            const lines = originalNewPath.split(\"\\n\");\n            lineIncrease = lines.length - 1;\n            newPath = lines.pop()!.trim();\n          }\n          line += lineIncrease;\n\n          path = currentPath ? `${currentPath}.${newPath}` : newPath;\n\n          const existing = yamlKeys.find((item) => item.path === path && item.lineOfPath === line);\n          if (!existing) {\n            if (DEVYAMLKEYS) {\n              console.log(\"99\", path, line);\n            }\n            yamlKeys.push({ path, index: column, lineOfPath: line });\n          }\n        }\n        // Hier geht man in den tastchlichen Array rein:\n        object.value.items.forEach((array: any) => {\n          /* if (!yamlKeys.some((yk) => yk.path === path)) {\n            arrayIndex = -1;\n          }*/\n          if (DEVYAMLKEYS) {\n            console.log(\"arrayGetKeys\", array);\n          }\n          let arrayStartOffset;\n\n          for (const item of array.start) {\n            if (item.source === \"-\") {\n              arrayStartOffset = item.offset;\n              break;\n            }\n          }\n          let startOfArray: number;\n          if (arrayStartOffset) {\n            startOfArray = getLineNumber(document, arrayStartOffset);\n          }\n          arrayIndex++;\n\n          if (array && array.value && array.value.items) {\n            array.value.items.forEach((object2: any) => {\n              if (object2 && object2.key && object2.key.source) {\n                if (DEVYAMLKEYS) {\n                  console.log(\"object2\", object2);\n                }\n\n                const originalNewPath: string = object2.key.source.replace(/\\./g, \"/\");\n                let newPath: string = originalNewPath;\n                let line: number = getLineNumber(document, object2.key.offset);\n\n                const column: number = object2.key.indent;\n                if (line !== undefined && column !== undefined) {\n                  let lineIncrease = 0;\n                  if (originalNewPath.includes(\"\\n\")) {\n                    const lines = originalNewPath.split(\"\\n\");\n                    lineIncrease = lines.length - 1;\n                    newPath = lines.pop()!.trim();\n                  }\n                  line += lineIncrease;\n                  const path2: string = `${path}.${newPath}`;\n                  if (DEVYAMLKEYS) {\n                    console.log(\"88\", path2, line);\n                  }\n\n                  const existing = yamlKeys.find(\n                    (item) => item.path === path2 && item.lineOfPath === line\n                  );\n                  if (!existing) {\n                    yamlKeys.push({\n                      path: path2,\n                      index: column,\n                      lineOfPath: line,\n                      startOfArray,\n                      arrayIndex,\n                    });\n                  }\n                }\n                // Wenn der Array noch ein Array oder Objekt enthlt (nicht key/value, das wre nur object2.value):\n                if (\n                  object2.value &&\n                  object2.value.items &&\n                  object2.value.items[0] &&\n                  startOfArray &&\n                  arrayIndex >= 0\n                ) {\n                  if (DEVYAMLKEYS) {\n                    console.log(\"77object2\", [object2], path);\n                  }\n                  getAllYamlPaths(document, [object2], path, yamlKeys, arrayIndex, startOfArray);\n                }\n              }\n            });\n          }\n        });\n        // Fall Objekt (Genau wie Fall Array aufgebaut)\n      } else if (\n        object &&\n        object.key &&\n        typeof object.key === \"object\" &&\n        \"source\" in object.key &&\n        object.value &&\n        !object.value.source &&\n        object.value.items[0]\n      ) {\n        let originalNewPath = object.key.source.replace(/\\./g, \"/\");\n        let newPath = originalNewPath;\n        let path: string = originalNewPath;\n        let line: number = getLineNumber(document, object.key.offset);\n        const column: number = object.key.indent;\n\n        if (line !== undefined && column !== undefined) {\n          // If there are illegitimate keys above our key (key without colon), then these aren't taken into account:\n          let lineIncrease = 0;\n          if (originalNewPath.includes(\"\\n\")) {\n            const lines = originalNewPath.split(\"\\n\");\n            lineIncrease = lines.length - 1;\n            newPath = lines.pop().trim();\n          }\n          line += lineIncrease;\n          path = currentPath ? `${currentPath}.${newPath}` : newPath;\n\n          const existing = yamlKeys.find((item) => item.path === path && item.lineOfPath === line);\n          if (!existing) {\n            if (arrayIndex >= 0 && startOfArray) {\n              if (DEVYAMLKEYS) {\n                console.log(\"Ist Teil eines Arrays\", path, line, \"arrayIndex\", arrayIndex);\n              }\n              yamlKeys.push({ path, index: column, lineOfPath: line, startOfArray, arrayIndex });\n            } else {\n              if (DEVYAMLKEYS) {\n                console.log(\"Ist kein Teil eines Arrays\", path, line);\n              }\n              yamlKeys.push({ path, index: column, lineOfPath: line });\n            }\n          }\n        }\n        if (DEVYAMLKEYS) {\n          console.log(\"ursprung\", object);\n        }\n        object.value.items.forEach((item: any) => {\n          if (DEVYAMLKEYS) {\n            console.log(\"itemGetKeys\", item, arrayIndex);\n          }\n          if (item && item.key && item.key.source) {\n            const keyWithoutDot = item.key.source.replace(/\\./g, \"/\");\n            let newPath: string = keyWithoutDot;\n            let path2: string = keyWithoutDot;\n            let line: number = getLineNumber(document, item.key.offset);\n            const column: number = item.key.indent;\n            if (line !== undefined && column !== undefined) {\n              let lineIncrease = 0;\n              if (keyWithoutDot.includes(\"\\n\")) {\n                const lines = keyWithoutDot.split(\"\\n\");\n                lineIncrease = lines.length - 1;\n                newPath = lines.pop()!.trim();\n              }\n              line += lineIncrease;\n              path2 = `${path}.${newPath}`;\n\n              const existing = yamlKeys.find(\n                (item) => item.path === path2 && item.lineOfPath === line\n              );\n              if (!existing) {\n                if (arrayIndex >= 0 && startOfArray) {\n                  if (DEVYAMLKEYS) {\n                    console.log(\"2222\", path2, line, \"arrayIndex\", arrayIndex);\n                  }\n                  yamlKeys.push({\n                    path: path2,\n                    index: column,\n                    lineOfPath: line,\n                    startOfArray,\n                    arrayIndex,\n                  });\n                } else {\n                  if (DEVYAMLKEYS) {\n                    console.log(\"1111\", path2, line);\n                  }\n                  yamlKeys.push({ path: path2, index: column, lineOfPath: line });\n                }\n              }\n            }\n\n            // Wenn das Objekt noch ein Objekt oder Array enthlt:\n            if (item.value && item.value.items) {\n              if (DEVYAMLKEYS) {\n                console.log(\"item.value.items\", item.value.items, path2);\n              }\n              if (arrayIndex >= 0 && startOfArray) {\n                getAllYamlPaths(\n                  document,\n                  item.value.items,\n                  path2,\n                  yamlKeys,\n                  arrayIndex,\n                  startOfArray\n                );\n              } else {\n                getAllYamlPaths(document, item.value.items, path2, yamlKeys);\n              }\n            }\n          }\n        });\n        // Fall einzelner Key (Funktion wird hier nicht nochmal aufgerufen, der Key wird einfach eingetragen)\n      } else if (object && object.key && object.key.source) {\n        if (DEVYAMLKEYS) {\n          console.log(\"objectGetKeys\", object);\n        }\n\n        const originalNewPath = object.key.source.replace(/\\./g, \"/\");\n        let newPath: string = originalNewPath;\n\n        let line: number = getLineNumber(document, object.key.offset);\n        const column: number = object.key.indent;\n        if (line !== undefined && column !== undefined) {\n          let lineIncrease = 0;\n          if (originalNewPath.includes(\"\\n\")) {\n            const lines = originalNewPath.split(\"\\n\");\n            lineIncrease = lines.length - 1;\n            newPath = lines.pop()!.trim();\n          }\n          line += lineIncrease;\n          const path: string = currentPath ? `${currentPath}.${newPath}` : newPath;\n          if (DEVYAMLKEYS) {\n            console.log(\"object.key\", object.key, currentPath, newPath);\n          }\n\n          const existing = yamlKeys.find((item) => item.path === path && item.lineOfPath === line);\n          if (!existing) {\n            if (arrayIndex >= 0 && startOfArray) {\n              if (DEVYAMLKEYS) {\n                console.log(\"Kommt das vor?\", path, line, \"arrayIndex\", arrayIndex);\n              }\n              yamlKeys.push({ path, index: column, lineOfPath: line, startOfArray, arrayIndex });\n            } else {\n              if (DEVYAMLKEYS) {\n                console.log(\"Einzelner Key als kein Teil eines Arrays\", path, line);\n              }\n              yamlKeys.push({ path, index: column, lineOfPath: line });\n            }\n          }\n        }\n      }\n    });\n  }\n  yamlKeys.sort((a, b) => a.lineOfPath - b.lineOfPath);\n\n  return yamlKeys;\n}\n\nfunction getLineNumber(documentText: any, offset: number) {\n  const lines = documentText.split(\"\\n\");\n  let currentOffset = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    currentOffset += lines[i].length + 1;\n    if (currentOffset > offset) {\n      return i + 1;\n    }\n  }\n\n  // If the offset is beyond the end of the document\n  return lines.length + 1;\n}\nexport function getLinesForArrayIndex(\n  allYamlKeys: {\n    path: string;\n    index: number;\n    lineOfPath: number | null;\n    startOfArray?: number;\n    arrayIndex?: number;\n  }[],\n  index: number,\n  path: string\n): number | undefined {\n  let line: number = 0;\n  if (DEVYAMLKEYS) {\n    console.log(\"pathMinLine\", path);\n  }\n  const pathToUse = path.replace(/\\[\\d+\\]/g, \"\");\n\n  for (const obj of allYamlKeys) {\n    if (DEVYAMLKEYS) {\n      console.log(\n        \"startOfArray\",\n        obj.startOfArray,\n        \"index\",\n        obj.arrayIndex,\n        index,\n        \"path\",\n        obj.path,\n        \"path2\",\n        pathToUse,\n        \"path3\",\n        path\n      );\n    }\n    if (\n      obj.startOfArray &&\n      obj.path &&\n      pathToUse &&\n      obj.arrayIndex === index &&\n      obj.path === pathToUse\n    ) {\n      line = obj.startOfArray;\n      console.log(\"lineYamlArrays\", line);\n      break;\n    }\n  }\n  if (DEVYAMLKEYS) {\n    console.log(\"pathiToUse\", pathToUse);\n  }\n\n  if (line > 0) {\n    return line;\n  }\n}\nexport function getMaxLine(\n  allYamlKeys: {\n    path: string;\n    index: number;\n    lineOfPath: number | undefined;\n    startOfArray?: number;\n    arrayIndex?: number;\n  }[],\n  minLine: number,\n  document: vscode.TextDocument\n): number | undefined {\n  let myItem:\n    | {\n        path: string;\n        index: number;\n        lineOfPath: number | undefined;\n        startOfArray?: number;\n        arrayIndex?: number;\n      }\n    | undefined = undefined;\n  while (!myItem) {\n    myItem = allYamlKeys.find((item) => item.lineOfPath === minLine);\n    minLine++;\n  }\n  let startIndex = 0;\n  if (myItem) {\n    startIndex = allYamlKeys.findIndex((item) => item === myItem);\n  }\n\n  if (startIndex > 0) {\n    for (let i = startIndex; i < allYamlKeys.length; i++) {\n      const currentItem = allYamlKeys[i];\n      if (DEVYAMLKEYS) {\n        console.log(\"currentItem\", currentItem);\n        console.log(\"startIndex\", startIndex, myItem);\n      }\n\n      let lineOfHyphenBeforeCurrentItem = -1;\n      if (currentItem && currentItem.lineOfPath) {\n        for (let lineIndex = minLine; lineIndex < currentItem.lineOfPath; lineIndex++) {\n          const line = document.lineAt(lineIndex).text;\n          const hyphenIndex = line.indexOf(\"-\");\n          if (DEVYAMLKEYS) {\n            console.log(\"IndexYaml1\", lineIndex, hyphenIndex);\n          }\n          if (hyphenIndex !== -1 && hyphenIndex <= myItem.index - 2) {\n            if (DEVYAMLKEYS) {\n              console.log(\"IndexYaml\", lineIndex, hyphenIndex);\n            }\n            lineOfHyphenBeforeCurrentItem = lineIndex;\n          }\n        }\n      }\n\n      if (lineOfHyphenBeforeCurrentItem !== -1) {\n        return lineOfHyphenBeforeCurrentItem;\n      } else if (\n        (myItem && currentItem.startOfArray !== myItem.startOfArray) ||\n        (myItem && !currentItem.hasOwnProperty(\"arrayIndex\")) ||\n        (myItem && i === allYamlKeys.length - 1)\n      ) {\n        if (DEVYAMLKEYS) {\n          console.log(\"iiii\", i);\n        }\n        if (i === allYamlKeys.length - 1 && currentItem && currentItem.lineOfPath) {\n          if (DEVYAMLKEYS) {\n            console.log(\"landet hier\", currentItem.lineOfPath);\n          }\n          return currentItem.lineOfPath + 2;\n        } else if (currentItem.startOfArray) {\n          return currentItem.startOfArray;\n        } else if (currentItem.lineOfPath) {\n          return currentItem.lineOfPath;\n        }\n      }\n    }\n  }\n}\nexport function extractIndexFromPath(path: string): number | null {\n  const regex = /\\[(\\d+)\\]/;\n\n  const match = path.match(regex);\n  if (DEVYAMLKEYS) {\n    console.log(\"match\", match);\n  }\n  if (match && match[1]) {\n    return parseInt(match[1], 10);\n  }\n\n  return null;\n}\n\nexport function hashDoc(document?: vscode.TextDocument): string {\n  if (document) {\n    return hashText(document.getText());\n  }\n\n  return \"\";\n}\n\nexport function hashText(text?: string): string {\n  if (text && text !== \"\") {\n    const hashString = md5(text);\n    if (DEVYAMLKEYS) {\n      console.log(\"Hash:\", hashString);\n    }\n\n    return hashString;\n  }\n\n  return \"\";\n}\n\nexport function getIndentation(yamlString: string) {\n  const lines = yamlString.split(\"\\n\");\n  for (let line of lines) {\n    const match = line.match(/^(\\s+)\\S/);\n    if (match) {\n      return match[1].length;\n    }\n  }\n  return 2; // Default to 2 if no indentation is found yet\n}\n\nexport function indentationOfYamlObjectAboveCursor(\n  allYamlKeys: {\n    path: string;\n    index: number;\n    lineOfPath: number | undefined;\n    startOfArray?: number;\n    arrayIndex?: number;\n  }[],\n  line: number,\n  pathAtCursor: string | undefined\n) {\n  let myItem:\n    | {\n        path: string;\n        index: number;\n        lineOfPath: number | undefined;\n        startOfArray?: number;\n        arrayIndex?: number;\n      }\n    | undefined = undefined;\n  console.log(\"line\", line);\n  while (!myItem && line > 0) {\n    myItem = allYamlKeys.find((item) => item.lineOfPath === line - 1 && item.path === pathAtCursor);\n    line--;\n  }\n  let indentationOfPropertyAbove = 0;\n  if (myItem) {\n    indentationOfPropertyAbove = myItem.index;\n  }\n\n  return indentationOfPropertyAbove;\n}\n","import transport from \"@xtracfg/transport-websocket\";\nimport {\n  activate as sharedActivate,\n  deactivate as sharedDeactivate,\n} from \"../shared/extension/index\";\nimport { ExtensionContext, workspace } from \"vscode\";\n\nexport function activate(context: ExtensionContext) {\n  sharedActivate(context, transport, { url: getUrl() });\n}\n\nexport function deactivate() {\n  sharedDeactivate();\n}\n\n// for some reason, the location is not set in the web worker as it should be (see https://developer.mozilla.org/en-US/docs/Web/API/WorkerLocation)\n// so we need to retrieve it manually so that the xtracfg websocket client can connect to the correct location\nconst getLocation = () => {\n  const baseUrl = workspace.getConfiguration(\"ldproxy-editor\").get<string>(\"baseUrl\");\n\n  if (baseUrl) {\n    const url = new URL(baseUrl);\n    const location = {\n      protocol: url.protocol,\n      host: url.host,\n      pathname: url.pathname,\n    };\n\n    return location;\n  }\n\n  const vscodeFileRoot = (self as any)._VSCODE_FILE_ROOT;\n\n  if (vscodeFileRoot) {\n    const url = new URL(vscodeFileRoot);\n    const location = {\n      protocol: url.protocol,\n      host: url.host,\n      pathname: url.pathname,\n    };\n\n    return location;\n  }\n\n  return self.location;\n};\n\nconst getUrl = () => {\n  //if (process.env.NODE_ENV === \"development\") {\n  return \"ws://localhost:8081/sock\";\n  // }\n\n  const location = getLocation();\n  const protocol = location.protocol === \"https:\" ? \"wss\" : \"ws\";\n  const path = location.pathname.endsWith(\"/\")\n    ? location.pathname.substring(0, location.pathname.length - 1)\n    : location.pathname;\n\n  return `${protocol}://${location.host}${path}/proxy/8081/`;\n};\n","module.exports = require(\"vscode\");","const a=(t,s={})=>{const r=t(s);return{send:d(s,r),listen:l(s,r),disconnect:c(s,r)}},d=({debug:t},s)=>r=>s().then(e=>{const n=JSON.stringify(r);t&&console.log(\"sending to xtracfg\",n),e.send(r)}).catch(e=>{console.error(\"Could not send command to xtracfg\",e.message||e)}),l=({debug:t},s)=>(r,e)=>s().then(n=>{n.listen(o=>{t&&console.log(\"received from xtracfg\",o);const i=u(o);i?e(i):r(o)})}).catch(n=>{console.error(\"Could not listen to xtracfg\",n.message||n)}),c=({debug:t},s)=>()=>s().then(r=>{r.stop()}).catch(r=>{console.error(\"Could not disconnect from xtracfg\",r.message||r)}),u=t=>{const s=t.error||\"\",r=t.results&&t.results.length>0?t.results[0].status:\"\",e=t.results&&t.results.length>0?t.results[0].message:\"\";if(!(s.length===0&&r!==\"ERROR\"))return s===\"No 'command' given: {}\"?{notification:\"Empty Fields\"}:e.includes(\"host\")&&!e.includes(\"refused\")?{fields:{host:e.split(\",\")[0]}}:s.includes(\"Host\")&&!e.includes(\"refused\")?{fields:{host:s}}:e.includes(\"database\")?{fields:{database:e}}:e.includes(\"user name\")?{fields:{user:e}}:e.includes(\"password\")?{fields:{user:e,password:e}}:s.includes(\"No id given\")?{fields:{id:s}}:s.includes(\"Id has to\")?{fields:{id:s}}:s.includes(\"with id\")?{fields:{id:s}}:e.includes(\"url\")?{fields:{url:e}}:e.includes(\"URL\")?{fields:{url:e}}:!e.includes(\"host\")&&!e.includes(\"Host\")&&!e.includes(\"url\")&&!e.includes(\"URL\")&&!e.includes(\"database\")&&!e.includes(\"user\")&&!e.includes(\"password\")||e.includes(\"refused\")?{notification:s.length>0?s:e}:{error:s,status:r,message:e}};export{a as connect};\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nexport default ws\n","import{Mutex as l}from\"async-mutex\";import p from\"isomorphic-ws\";const c=[],d=r=>{c.flat().forEach(n=>n(r))},f=({specific:r,debug:n})=>async()=>{const t=[];c.push(t);const a=w(r?.url,n);return a.then(o=>{o?.addEventListener(\"message\",s=>{if(typeof s.data!=\"string\")return;const i=JSON.parse(s.data);d(i)})}),{send:async o=>a.then(s=>{s?.send(JSON.stringify(o))}),listen:async o=>{t.push(o)},stop:async()=>{t.length=0,a.then(o=>o?.close())}}};var C=f;const u=new l;let e;const w=async(r,n)=>{const t=await u.acquire();if(e&&e.readyState===e.OPEN)return t(),Promise.resolve(e);if(!e||e.readyState===e.CLOSED||e.readyState===e.CLOSING){if(!r)return console.error(\"No websocket url given\"),Promise.reject(\"No websocket url given\");n&&console.log(\"CONNECTING to websocket\",r),e=new p(r)}return new Promise((a,o)=>{e.addEventListener(\"open\",()=>{a(e),t()}),e.addEventListener(\"error\",()=>{o(\"websocket error\"),t()}),e.addEventListener(\"close\",s=>{n&&s.wasClean?console.log(\"websocket was closed\",s.code,s.reason):s.wasClean||console.error(\"websocket was closed unexpectedly\",s.code,s.reason)})})};export{C as default,f as transport};\n","const ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\n\nexport { ALIAS, DOC, MAP, NODE_TYPE, PAIR, SCALAR, SEQ, hasAnchor, isAlias, isCollection, isDocument, isMap, isNode, isPair, isScalar, isSeq };\n","import { isDocument, isNode, isPair, isCollection, isMap, isSeq, isScalar, isAlias } from './nodes/identity.js';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexport { visit, visitAsync };\n","import { isNode } from '../nodes/identity.js';\nimport { visit } from '../visit.js';\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix) {\n            try {\n                return prefix + decodeURIComponent(suffix);\n            }\n            catch (error) {\n                onError(String(error));\n                return null;\n            }\n        }\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {\n            const tags = {};\n            visit(doc.contents, (_key, node) => {\n                if (isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexport { Directives };\n","import { isScalar, isCollection } from '../nodes/identity.js';\nimport { visit } from '../visit.js';\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            if (!prevAnchors)\n                prevAnchors = anchorNames(doc);\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (isScalar(ref.node) || isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexport { anchorIsValid, anchorNames, createNodeAnchors, findNewAnchor };\n","/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                // eslint-disable-next-line @typescript-eslint/no-array-delete\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexport { applyReviver };\n","import { hasAnchor } from './identity.js';\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexport { toJS };\n","import { applyReviver } from '../doc/applyReviver.js';\nimport { NODE_TYPE, isDocument } from './identity.js';\nimport { toJS } from './toJS.js';\n\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** A plain JavaScript representation of this node. */\n    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        if (!isDocument(doc))\n            throw new TypeError('A document argument is required');\n        const ctx = {\n            anchors: new Map(),\n            doc,\n            keep: true,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this, '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n}\n\nexport { NodeBase };\n","import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { ALIAS, isAlias, isCollection, isPair } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexport { Alias };\n","import { SCALAR } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends NodeBase {\n    constructor(value) {\n        super(SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexport { Scalar, isScalarValue };\n","import { Alias } from '../nodes/Alias.js';\nimport { isNode, isPair, MAP, SEQ, isDocument } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (isDocument(value))\n        value = value.contents;\n    if (isNode(value))\n        return value;\n    if (isPair(value)) {\n        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            if (!ref.anchor)\n                ref.anchor = onAnchor(value);\n            return new Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[SEQ]\n                    : schema[MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexport { createNode };\n","import { createNode } from '../doc/createNode.js';\nimport { isNode, isPair, isCollection, isScalar } from './identity.js';\nimport { NodeBase } from './Node.js';\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && isScalar(node) ? node.value : node;\n        else\n            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\nexport { Collection, collectionFromPath, isEmptyPath };\n","/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexport { indentComment, lineComment, stringifyComment };\n","const FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\n// The negative lookbehind avoids a polynomial search,\n// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind\nlet blockEndNewlines;\ntry {\n    blockEndNewlines = new RegExp('(^|(?<!\\n))\\n+(?!\\n|$)', 'g');\n}\ncatch {\n    blockEndNewlines = /\\n+(?!\\n|$)/g;\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(blockEndNewlines, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    // Leading | or > is added later\n    let header = (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (!literal) {\n        const foldedValue = value\n            .replace(/\\n+/g, '\\n$&')\n            .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n            .replace(/\\n+/g, `$&${indent}`);\n        let literalFallback = false;\n        const foldOptions = getFoldOptions(ctx, true);\n        if (blockQuote !== 'folded' && type !== Scalar.BLOCK_FOLDED) {\n            foldOptions.onOverflow = () => {\n                literalFallback = true;\n            };\n        }\n        const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);\n        if (!literalFallback)\n            return `>${header}\\n${indent}${body}`;\n    }\n    value = value.replace(/\\n+/g, `$&${indent}`);\n    return `|${header}\\n${indent}${start}${value}${end}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && value.includes('\\n')) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.BLOCK_FOLDED:\n            case Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexport { stringifyString };\n","import { anchorIsValid } from '../doc/anchors.js';\nimport { isPair, isAlias, isNode, isScalar, isCollection } from '../nodes/identity.js';\nimport { stringifyComment } from './stringifyComment.js';\nimport { stringifyString } from './stringifyString.js';\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (isScalar(item)) {\n        obj = item.value;\n        let match = tags.filter(t => t.identify?.(obj));\n        if (match.length > 1) {\n            const testMatch = match.filter(t => t.test);\n            if (testMatch.length > 0)\n                match = testMatch;\n        }\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;\n    if (anchor && anchorIsValid(anchor)) {\n        anchors.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    if (!tagObj)\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : isScalar(node)\n            ? stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexport { createStringifyContext, stringify };\n","function debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        console.warn(warning);\n    }\n}\n\nexport { debug, warn };\n","import { isScalar, isAlias, isSeq, isMap } from '../../nodes/identity.js';\nimport { Scalar } from '../../nodes/Scalar.js';\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n    identify: value => value === MERGE_KEY ||\n        (typeof value === 'symbol' && value.description === MERGE_KEY),\n    default: 'key',\n    tag: 'tag:yaml.org,2002:merge',\n    test: /^<<$/,\n    resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {\n        addToJSMap: addMergeToJSMap\n    }),\n    stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) ||\n    (isScalar(key) &&\n        (!key.type || key.type === Scalar.PLAIN) &&\n        merge.identify(key.value))) &&\n    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n    value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (isSeq(value))\n        for (const it of value.items)\n            mergeValue(ctx, map, it);\n    else if (Array.isArray(value))\n        for (const it of value)\n            mergeValue(ctx, map, it);\n    else\n        mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\n\nexport { addMergeToJSMap, isMergeKey, merge };\n","import { warn } from '../log.js';\nimport { isMergeKey, addMergeToJSMap } from '../schema/yaml-1.1/merge.js';\nimport { createStringifyContext } from '../stringify/stringify.js';\nimport { isNode } from './identity.js';\nimport { toJS } from './toJS.js';\n\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (isNode(key) && key.addToJSMap)\n        key.addToJSMap(ctx, map, value);\n    // TODO: Should drop this special case for bare << handling\n    else if (isMergeKey(ctx, key))\n        addMergeToJSMap(ctx, map, value);\n    else {\n        const jsKey = toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (isNode(key) && ctx?.doc) {\n        const strCtx = createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexport { addPairToJSMap };\n","import { createNode } from '../doc/createNode.js';\nimport { stringifyPair } from '../stringify/stringifyPair.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { NODE_TYPE, PAIR, isNode } from './identity.js';\n\nfunction createPair(key, value, ctx) {\n    const k = createNode(key, undefined, ctx);\n    const v = createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, NODE_TYPE, { value: PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (isNode(key))\n            key = key.clone(schema);\n        if (isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexport { Pair, createPair };\n","import { isCollection, isNode, isScalar, isSeq } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (isCollection(key) || (!isNode(key) && typeof key === 'object')) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            isCollection(key) ||\n            (isScalar(key)\n                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexport { stringifyPair };\n","import { isNode, isPair } from '../nodes/identity.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik?.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        return start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;\n        }\n        if (reqNewline) {\n            let str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            return `${str}\\n${indent}${end}`;\n        }\n        else {\n            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexport { stringifyCollection };\n","import { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { Collection } from './Collection.js';\nimport { isPair, isScalar, MAP } from './identity.js';\nimport { Pair, createPair } from './Pair.js';\nimport { isScalarValue } from './Scalar.js';\n\nfunction findPair(items, key) {\n    const k = isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(MAP, schema);\n        this.items = [];\n    }\n    /**\n     * A generic collection parsing method that can be extended\n     * to other node classes that inherit from YAMLMap\n     */\n    static from(schema, obj, ctx) {\n        const { keepUndefined, replacer } = ctx;\n        const map = new this(schema);\n        const add = (key, value) => {\n            if (typeof replacer === 'function')\n                value = replacer.call(obj, key, value);\n            else if (Array.isArray(replacer) && !replacer.includes(key))\n                return;\n            if (value !== undefined || keepUndefined)\n                map.items.push(createPair(key, value, ctx));\n        };\n        if (obj instanceof Map) {\n            for (const [key, value] of obj)\n                add(key, value);\n        }\n        else if (obj && typeof obj === 'object') {\n            for (const key of Object.keys(obj))\n                add(key, obj[key]);\n        }\n        if (typeof schema.sortMapEntries === 'function') {\n            map.items.sort(schema.sortMapEntries);\n        }\n        return map;\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (isScalar(prev.value) && isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexport { YAMLMap, findPair };\n","import { isMap } from '../../nodes/identity.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\n\nconst map = {\n    collection: 'map',\n    default: true,\n    nodeClass: YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)\n};\n\nexport { map };\n","import { createNode } from '../doc/createNode.js';\nimport { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { Collection } from './Collection.js';\nimport { SEQ, isScalar } from './identity.js';\nimport { isScalarValue } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nclass YAMLSeq extends Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (isScalar(prev) && isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n    static from(schema, obj, ctx) {\n        const { replacer } = ctx;\n        const seq = new this(schema);\n        if (obj && Symbol.iterator in Object(obj)) {\n            let i = 0;\n            for (let it of obj) {\n                if (typeof replacer === 'function') {\n                    const key = obj instanceof Set ? it : String(i++);\n                    it = replacer.call(obj, key, it);\n                }\n                seq.items.push(createNode(it, undefined, ctx));\n            }\n        }\n        return seq;\n    }\n}\nfunction asItemIndex(key) {\n    let idx = isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexport { YAMLSeq };\n","import { isSeq } from '../../nodes/identity.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nconst seq = {\n    collection: 'seq',\n    default: true,\n    nodeClass: YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    },\n    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)\n};\n\nexport { seq };\n","import { stringifyString } from '../../stringify/stringifyString.js';\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { string };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexport { nullTag };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexport { boolTag };\n","function stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexport { stringifyNumber };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intHex, intOct };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { boolTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intOct, int, intHex } from './int.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    boolTag,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float\n];\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { map } from '../common/map.js';\nimport { seq } from '../common/seq.js';\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true$|^false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map, seq].concat(jsonScalars, jsonError);\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n","import { isSeq, isPair, isMap } from '../../nodes/identity.js';\nimport { Pair, createPair } from '../../nodes/Pair.js';\nimport { Scalar } from '../../nodes/Scalar.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nfunction resolvePairs(seq, onError) {\n    if (isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (isPair(item))\n                continue;\n            else if (isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair(new Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = isPair(item) ? item : new Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else {\n                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);\n                }\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexport { createPairs, pairs, resolvePairs };\n","import { isScalar, isPair } from '../../nodes/identity.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { resolvePairs, createPairs } from './pairs.js';\n\nclass YAMLOMap extends YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (isPair(pair)) {\n                key = toJS(pair.key, '', ctx);\n                value = toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs = createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs = resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs.items) {\n            if (isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexport { YAMLOMap, omap };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,\n    resolve: () => new Scalar(false),\n    stringify: boolStringify\n};\n\nexport { falseTag, trueTag };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF)|\\.nan|\\.NaN|\\.NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intBin, intHex, intOct };\n","import { isMap, isPair, isScalar } from '../../nodes/identity.js';\nimport { Pair, createPair } from '../../nodes/Pair.js';\nimport { YAMLMap, findPair } from '../../nodes/YAMLMap.js';\n\nclass YAMLSet extends YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair(key.key, null);\n        else\n            pair = new Pair(key, null);\n        const prev = findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = findPair(this.items, key);\n        return !keepPair && isPair(pair)\n            ? isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n    static from(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new this(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(createPair(value, null, ctx));\n            }\n        return set;\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),\n    resolve(map, onError) {\n        if (isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexport { YAMLSet, set };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => String(n).padStart(2, '0'))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value.toISOString().replace(/(T00:00:00)?\\.000Z$/, '')\n};\n\nexport { floatTime, intTime, timestamp };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { binary } from './binary.js';\nimport { trueTag, falseTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intBin, intOct, int, intHex } from './int.js';\nimport { merge } from './merge.js';\nimport { omap } from './omap.js';\nimport { pairs } from './pairs.js';\nimport { set } from './set.js';\nimport { intTime, floatTime, timestamp } from './timestamp.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    trueTag,\n    falseTag,\n    intBin,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float,\n    binary,\n    merge,\n    omap,\n    pairs,\n    set,\n    intTime,\n    floatTime,\n    timestamp\n];\n\nexport { schema };\n","import { map } from './common/map.js';\nimport { nullTag } from './common/null.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { boolTag } from './core/bool.js';\nimport { float, floatExp, floatNaN } from './core/float.js';\nimport { int, intHex, intOct } from './core/int.js';\nimport { schema } from './core/schema.js';\nimport { schema as schema$1 } from './json/schema.js';\nimport { binary } from './yaml-1.1/binary.js';\nimport { merge } from './yaml-1.1/merge.js';\nimport { omap } from './yaml-1.1/omap.js';\nimport { pairs } from './yaml-1.1/pairs.js';\nimport { schema as schema$2 } from './yaml-1.1/schema.js';\nimport { set } from './yaml-1.1/set.js';\nimport { timestamp, floatTime, intTime } from './yaml-1.1/timestamp.js';\n\nconst schemas = new Map([\n    ['core', schema],\n    ['failsafe', [map, seq, string]],\n    ['json', schema$1],\n    ['yaml11', schema$2],\n    ['yaml-1.1', schema$2]\n]);\nconst tagsByName = {\n    binary,\n    bool: boolTag,\n    float,\n    floatExp,\n    floatNaN,\n    floatTime,\n    int,\n    intHex,\n    intOct,\n    intTime,\n    map,\n    merge,\n    null: nullTag,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary,\n    'tag:yaml.org,2002:merge': merge,\n    'tag:yaml.org,2002:omap': omap,\n    'tag:yaml.org,2002:pairs': pairs,\n    'tag:yaml.org,2002:set': set,\n    'tag:yaml.org,2002:timestamp': timestamp\n};\nfunction getTags(customTags, schemaName, addMergeTag) {\n    const schemaTags = schemas.get(schemaName);\n    if (schemaTags && !customTags) {\n        return addMergeTag && !schemaTags.includes(merge)\n            ? schemaTags.concat(merge)\n            : schemaTags.slice();\n    }\n    let tags = schemaTags;\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    if (addMergeTag)\n        tags = tags.concat(merge);\n    return tags.reduce((tags, tag) => {\n        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;\n        if (!tagObj) {\n            const tagName = JSON.stringify(tag);\n            const keys = Object.keys(tagsByName)\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);\n        }\n        if (!tags.includes(tagObj))\n            tags.push(tagObj);\n        return tags;\n    }, []);\n}\n\nexport { coreKnownTags, getTags };\n","import { MAP, SCALAR, SEQ } from '../nodes/identity.js';\nimport { map } from './common/map.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { getTags, coreKnownTags } from './tags.js';\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? getTags(compat, 'compat')\n            : compat\n                ? getTags(null, compat)\n                : null;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getTags(customTags, this.name, merge);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, MAP, { value: map });\n        Object.defineProperty(this, SCALAR, { value: string });\n        Object.defineProperty(this, SEQ, { value: seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexport { Schema };\n","import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            stringKeys: false,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        // @ts-expect-error We can't really know that this matches Contents.\n        this.contents =\n            value === undefined ? null : this.createNode(value, _replacer, options);\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        // @ts-expect-error We can't really know that this matches Contents.\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            // @ts-expect-error Presumed impossible if Strict extends false\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path)) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = value;\n        }\n        else if (this.contents == null) {\n            // @ts-expect-error We can't really know that this matches Contents.\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexport { Document };\n","import { isNode } from '../nodes/identity.js';\nimport { createStringifyContext, stringify } from './stringify.js';\nimport { indentComment, lineComment } from './stringifyComment.js';\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexport { stringifyDocument };\n","class YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexport { YAMLError, YAMLParseError, YAMLWarning, prettifyError };\n","function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n","function containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport { containsNewline };\n","import { containsNewline } from './util-contains-newline.js';\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexport { flowIndentCheck };\n","import { isScalar } from '../nodes/identity.js';\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b || (isScalar(a) && isScalar(b) && a.value === b.value);\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexport { mapIncludes };\n","import { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexport { resolveBlockMap };\n","function resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexport { resolveEnd };\n","import { isPair } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            //  key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexport { resolveFlowCollection };\n","import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt?.collection) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n","import { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveProps } from './resolve-props.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLSeq;\n    const seq = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            parentIndent: bs.indent,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexport { resolveBlockSeq };\n","import { Scalar } from '../nodes/Scalar.js';\n\nfunction resolveBlockScalar(ctx, scalar, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            if (trimIndent === 0 && !ctx.atRoot) {\n                const message = 'Block scalar values in collections must be indented';\n                onError(offset, 'BAD_INDENT', message);\n            }\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexport { resolveBlockScalar };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n","import { isScalar, SCALAR } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(ctx, token, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    let tag;\n    if (ctx.options.stringKeys && ctx.atKey) {\n        tag = ctx.schema[SCALAR];\n    }\n    else if (tagName)\n        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);\n    else if (token.type === 'scalar')\n        tag = findScalarTagByTest(ctx, value, token, onError);\n    else\n        tag = ctx.schema[SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR];\n}\nfunction findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&\n        tag.test?.test(value)) || schema[SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexport { composeScalar };\n","function emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexport { emptyScalarPosition };\n","import { Alias } from '../nodes/Alias.js';\nimport { isScalar } from '../nodes/identity.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n","import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n","import { Document } from '../doc/Document.js';\nimport { composeNode, composeEmptyNode } from './compose-node.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document(undefined, opts);\n    const ctx = {\n        atKey: false,\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        parentIndent: 0,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    // @ts-expect-error If Contents is set, let's trust the user\n    doc.contents = value\n        ? composeNode(ctx, value, props, onError)\n        : composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexport { composeDoc };\n","import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar({ options: { strict } }, token, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexport { createScalarToken, resolveAsScalar, setScalarValue };\n","/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexport { stringify };\n","const BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]`  Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null`  Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]`  Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token`  The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexport { visit };\n","export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar.js';\nexport { stringify } from './cst-stringify.js';\nexport { visit } from './cst-visit.js';\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexport { BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, prettyToken, tokenType };\n","import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = new Set('0123456789ABCDEFabcdef');\nconst tagChars = new Set(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\");\nconst flowIndicatorChars = new Set(',[]{}');\nconst invalidAnchorChars = new Set(' ,[]{}\\n\\r\\t');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            if (typeof source !== 'string')\n                throw TypeError('source is not a string');\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            let cs = line.indexOf('#');\n            while (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t') {\n                    dirEnd = cs - 1;\n                    break;\n                }\n                else {\n                    cs = line.indexOf('#', cs + 1);\n                }\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return s === '---' ? 'doc' : 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else {\n                this.indentNext =\n                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);\n            }\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        // Trailing insufficiently indented tabs are invalid.\n        // To catch that during parsing, we include them in the block scalar value.\n        let i = nl + 1;\n        ch = this.buffer[i];\n        while (ch === ' ')\n            ch = this.buffer[++i];\n        if (ch === '\\t') {\n            while (ch === '\\t' || ch === ' ' || ch === '\\r' || ch === '\\n')\n                ch = this.buffer[++i];\n            nl = i - 1;\n        }\n        else if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && flowIndicatorChars.has(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.has(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.has(this.buffer[i + 1]) &&\n                    hexDigits.has(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexport { Lexer };\n","/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexport { LineCounter };\n","import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !it.explicitKey;\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n            const atNextItem = atMapIndent &&\n                (it.sep || it.explicitKey) &&\n                this.type !== 'seq-item-ind';\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !it.explicitKey) {\n                        it.start.push(this.sourceToken);\n                        it.explicitKey = true;\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start, explicitKey: true });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken], explicitKey: true }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (it.explicitKey) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key;\n                            // @ts-expect-error type guard is wrong here\n                            delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atMapIndent && bv.type !== 'block-seq') {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, explicitKey: true }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n","import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { isDocument } from './nodes/identity.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n","// `export * as default from ...` fails on Webpack v4\n// https://github.com/eemeli/yaml/issues/228\nimport * as YAML from './dist/index.js'\nexport default YAML\nexport * from './dist/index.js'\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.amdO = {};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(5821);\n"],"names":["INPUT_ERROR","WINDOW","window","root","JS_MD5_NO_WINDOW","WEB_WORKER","self","NODE_JS","JS_MD5_NO_NODE_JS","process","versions","node","g","buffer8","COMMON_JS","JS_MD5_NO_COMMON_JS","module","exports","AMD","ARRAY_BUFFER","JS_MD5_NO_ARRAY_BUFFER","ArrayBuffer","HEX_CHARS","split","EXTRA","SHIFT","OUTPUT_TYPES","BASE64_ENCODE_CHAR","blocks","buffer","Uint8Array","Uint32Array","isArray","Array","obj","Object","prototype","toString","call","isView","JS_MD5_NO_ARRAY_BUFFER_IS_VIEW","constructor","formatMessage","message","type","Error","createOutputMethod","outputType","Md5","update","createHmacOutputMethod","key","HmacMd5","sharedMemory","this","h0","h1","h2","h3","start","bytes","hBytes","finalized","hashed","first","i","result","code","length","index","charCodeAt","array","oKeyPad","iKeyPad","b","inner","isString","lastByteIndex","hash","finalize","a","c","d","bc","da","hex","digest","arrayBuffer","base64","v1","v2","v3","base64Str","innerHash","method","bufferFrom","crypto","Buffer","from","JS_MD5_NO_BUFFER_FROM","createHash","nodeWrap","create","createMethod","md5","hmac","createHmacMethod","loader","dumper","renamed","to","Type","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SCHEMA","load","loadAll","dump","YAMLException","types","binary","float","map","null","pairs","set","timestamp","bool","int","merge","omap","seq","str","safeLoad","safeLoadAll","safeDump","isNothing","subject","isObject","toArray","sequence","repeat","string","count","cycle","isNegativeZero","number","Number","NEGATIVE_INFINITY","extend","target","source","sourceKeys","keys","common","_toString","_hasOwnProperty","hasOwnProperty","CHAR_BOM","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","encodeHex","character","handle","toUpperCase","State","options","schema","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","styleMap","tag","style","String","slice","compiledTypeMap","styleAliases","compileStyleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","line","ind","position","next","indexOf","generateNextLine","state","level","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","codePointAt","pos","second","needIndentIndicator","test","writeScalar","iskey","min","singleLineOnly","indentPerLevel","testAmbiguousType","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","isPlainSafeLast","chooseScalarStyle","resolve","testImplicitResolving","replace","blockHeader","dropEndingNewline","width","moreIndented","match","nextLF","lineRe","lastIndex","foldLine","prevMoreIndented","exec","prefix","foldString","escapeSeq","escapeString","indentIndicator","clip","end","breakRe","curr","writeBlockSequence","object","compact","value","_result","_tag","writeNode","detectType","explicit","typeList","instanceOf","predicate","multi","representName","represent","defaultStyle","block","isblockseq","tagStr","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","writeFlowSequence","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","input","formatError","exception","where","reason","mark","name","column","snippet","captureStackTrace","stack","makeSnippet","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","filename","onWarning","legacy","json","listener","typeMap","lineStart","lineIndent","firstTabInLine","documents","generateError","throwError","throwWarning","directiveHandlers","YAML","args","major","minor","version","parseInt","checkLineBreaks","TAG","tagMap","decodeURIComponent","err","captureSegment","checkJson","_position","_length","_character","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startLineStart","startPos","defineProperty","configurable","enumerable","writable","readLineBreak","ch","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readBlockSequence","nodeIndent","_line","_anchor","anchor","detected","anchorMap","composeNode","kind","readTagProperty","tagHandle","tagName","isVerbatim","isNamed","readAnchorProperty","parentIndent","nodeContext","allowToSeek","allowCompact","allowBlockStyles","allowBlockScalars","allowBlockCollections","typeIndex","typeQuantity","flowIndent","blockIndent","indentStatus","atNewLine","hasContent","following","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readBlockMapping","_lineStart","_pos","terminator","isPair","isExplicitPair","isMapping","readNext","readFlowCollection","captureStart","folding","tmp","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockScalar","captureEnd","readSingleQuotedScalar","hexLength","hexResult","readDoubleQuotedScalar","alias","readAlias","withinFlowCollection","hasPendingContent","_lineIndent","_kind","readPlainScalar","construct","readDocument","directiveName","directiveArgs","documentStart","hasDirectives","loadDocuments","nullpos","iterator","compileList","forEach","currentType","newIndex","previousType","previousIndex","definition","implicit","concat","loadKind","scalar","mapping","fallback","collectType","arguments","compileMap","getLine","lineEnd","maxLineLength","head","tail","maxHalfLength","floor","padStart","maxLength","linesBefore","linesAfter","re","lineStarts","lineEnds","foundLineNo","lineNoLength","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","data","BASE64_MAP","idx","bitlen","charAt","tailbits","bits","lowercase","uppercase","camelcase","YAML_FLOAT_PATTERN","RegExp","SCIENTIFIC_WITHOUT_DOT","sign","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","isOctCode","isDecCode","hasDigits","octal","decimal","hexadecimal","canonical","empty","pair","pairKey","pairHasKey","objectKeys","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","year","month","day","hour","minute","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","lastSegmentLength","lastSlash","dots","lastSlashIndex","lastIndexOf","posix","cwd","resolvedPath","resolvedAbsolute","undefined","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","base","_format","parse","ret","delimiter","win32","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","noop","nextTick","apply","title","browser","env","argv","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","chdir","umask","context","transportCreator","additionalTransportOptions","initialized","DEV","console","log","extension","id","isActive","extensionMode","transport","initSchemas","register","registeTreeViews","registerShowAutoCreate","registerShowAutoCreateValues","registerHover","registerCompletions","registerValueCompletions","registerDiagnostics","registerDocHandlers","registerCodeActions","onDocUpdate","DocEvent","OPEN","activeTextEditor","document","onDidChangeActiveTextEditor","editor","workspace","onDidChangeTextDocument","event","activeEditor","CHANGE","onDidSaveTextDocument","SAVE","text","getText","uri","hashText","allYamlKeys","parseYaml","updateHover","updateCompletions","updateValueCompletions","updateDiagnostics","vscode","CodeActionKind","QuickFix","enumArray","specifiedDefs","definitionsMap","async","docUri","docHash","newAllYamlKeys","getSchema","buildEnumArray","extractDocRefs","uniqueDefs","removeDuplicates","getDefinitionsMap","languages","registerCompletionItemProvider","referencesFromSpecifiedDefs","nonIndentedKeysAndArrays","additionalReferencesFromSpecifiedDefs","provideCompletionItems","textBeforeCursor","textBeforeCursorLength","indentation","indentationOfpathAtCursor","indentationUsedInYaml","pathAtCursor","gatherInformation","currentStartOfArray","find","item","lineOfPath","startOfArray","myLine","lineAt","trim","startsWith","shouldShowCompletionsProv1","getRefCompletionsProv1","completions","defObj","ref","finalPath","specifiedDefsPath","arrayIndex","extractIndexFromPath","minLine","getLinesForArrayIndex","maxLine","getMaxLine","keyAtStartOfArray","columnOfArray","includes","groupname","deprecated","some","fullPath","completion","createCompletionItem","shouldFilterExistingCharacters","shouldShowCompletionsProv2","filterExistingCharacters","existing","existingComp","label","refCompletions","addRef","refinedObjPath","objPath","foundObj","addRefOfObjInArray","lastDotIndex","pathAfterLastDot","substring","partsInObjPath","relevantRefs","filter","shouldShowCompletionsProv3","key2","obj2","finalValue","createCompletionItemProv3","insertText","detail","command","xtracfg","diagnosticsResults","collection","createDiagnosticCollection","connect","specific","debug","listen","response","results","details","hasOwn","status","pending","error","diagnostics","getRelativeFilePath","Promise","reject","send","subcommand","getWorkspacePath","verbose","requestDiagnostics","info","infoText","infoWord","endsWith","infoWordWithoutIndex","lastKey","matches","matchAll","lastMatch","lastKeyIndex","foundItem","lineText","keyIndex","offsetAt","Position","startPosition","positionAt","endPosition","diagnostic","Diagnostic","Range","DiagnosticSeverity","Warning","yamlKeysHover","hoverStatus","registerHoverProvider","hover","provideHover","hashDoc","lineOfWord","lineCharacter","pathInYaml","pathSplit","pathInYamlToUse","pathInYamlLastKey","hoverResult","wordInDefinitionsMap","pathForArray","description","hoverText","Hover","pathInYamlParts","secondLastKey","thirdLastKey","possibleRefWord","matchingObject","matchingObjects","matchingObj","possibleAddRefWord","provider","lastColonIndex","textBetweenColonAndCursor","valueCompletions","keyAtCursor","textBeforeColon","substringBeforeColon","lastSpaceIndex","findKeyForValueCompletion","yamlKeysObject","pathAtCursorTwoLastParts","pathAtCursorThreeLastParts","pathAtCursorSplit","enumObj","myEnum","enum","enumGroupname","CompletionItem","CompletionItemKind","Method","def","workspaceFolders","watcherOnDidDelete","createFileSystemWatcher","RelativePattern","watcherOnDidCreate","workspaceUri","getWorkspaceUri","commands","registerCommand","AutoCreatePanel","render","extensionUri","static","_panel","_extensionUri","_disposables","panel","onDidDispose","dispose","webview","html","_getWebviewContent","_setWebviewMessageListener","onDidCreate","postMessage","existingGeopackages","listGpkgFilesInDirectory","onDidDelete","deletedGpkg","fsPath","currentPanel","reveal","ViewColumn","One","createWebviewPanel","enableScripts","localResourceRoots","Uri","joinPath","disconnect","disposable","pop","reload","stylesUri","getUri","scriptUri","nonce","getNonce","cspSource","onDidReceiveMessage","showInformationMessage","showErrorMessage","workspaceRoot","fileUri","with","executeCommand","preview","uploadedGpkg","setCancel","request","AutoCreateValuesPanel","existingApis","listApisInDirectory","directoryUri","directoryPath","readAllFilesInDirectory","file","relativePath","hasServicesBeforeLastPart","doesNotContainDefaults","baseName","cancel","files","fs","readDirectory","allFiles","FileType","File","Directory","subDirectoryFiles","textWithoutHyphen","enumItem","documentation","MarkdownString","getPathAtCursor","indexToUse","getPathAtCursorString","search","getIndentation","indentationOfYamlObjectAboveCursor","isCompletionValid","addRefCompletions","isValidCompletion","DEVYAMLKEYS","allMaps","schemaDefs","$defs","allRefs","processProperties","requiredProperties","getRequiredProperties","findObjectsWithRef","defs","lastPartValue","lastPartValueAddRed","properties","propKey","propDefinition","reference","$ref","propDefinitionType","referenceInConditionLastPart","allOf","then","items","if","additionalReference","additionalProperties","additionalReferenceInConditionLastPart","uniqueKey","counter","anyOf","anyOfItem","deprecatedProperty","lastPartValueArray","hasNewReferences","nestedDefinitionsMap","requiredPropertieObject","requiredProperty","prop","groupName","noCondition","definitions","localEnumArray","enumValue","existingEnum","oneOf","existingWithTrue","existingWithFalse","gpkgToUpload","cancelPromise","intervalId","setInterval","clearInterval","uploadPromise","binaryString","atob","uint8Array","filePath","createDirectory","stat","writeFile","race","delete","getWorkspacePathNormalized","getCurrentFilePath","workspacePath","documentGetText","allSpecifiedDefs","config","yaml","conditions","extractConditions","condition","resultObject","matchesCondition","allConditionsMet","TOP_LEVEL_REF","property","discriminatorKey","discriminatorValue","myRef","conditionKeys","const","conditionRef","topLevelDefs","uniquePaths","returnObjects","conditionEntry","conditionValue","lowerCasedConditionValue","matchingPaths","getConfigValues","targetKey","newPath","currentKey","registrations","registration","subscriptions","allSchemas","fileTypes","rej","fileType","schemas","getCurrentFileType","subProperty","extractSingleRefs","subSchema","currentFilePath","possible","random","pathList","asWebviewUri","yamlObject","token","Parser","getAllYamlPaths","pathToUse","myItem","startIndex","findIndex","currentItem","lineOfHyphenBeforeCurrentItem","lineIndex","hyphenIndex","yamlString","lines","indentationOfPropertyAbove","currentPath","yamlKeys","originalNewPath","getLineNumber","offset","lineIncrease","arrayStartOffset","object2","path2","keyWithoutDot","documentText","currentOffset","hashString","url","getUrl","require","t","s","r","l","n","catch","o","u","stop","notification","fields","host","database","user","password","E_CANCELED","Semaphore","_value","_cancelError","_queue","_weightedWaiters","acquire","weight","priority","task","findIndexFromEnd","other","_dispatchItem","splice","runExclusive","callback_1","thisArg","_arguments","generator","callback","release","P","fulfilled","step","rejected","done","waitForUnlock","_couldLockImmediately","v","insertSorted","isLocked","getValue","setValue","_dispatchQueue","entry","_drainUnlockWaiters","shift","previousValue","_newReleaser","called","waiters","waiter","queuedPriority","ws","WebSocket","MozWebSocket","f","w","addEventListener","flat","close","C","cancelError","_semaphore","releaser","readyState","CLOSED","CLOSING","wasClean","ALIAS","Symbol","for","DOC","MAP","PAIR","SCALAR","SEQ","NODE_TYPE","isAlias","isDocument","isMap","isScalar","isSeq","isCollection","isNode","BREAK","SKIP","REMOVE","visit","visitor","visitor_","initVisitor","visit_","contents","freeze","ctrl","callVisitor","replaceNode","ci","ck","cv","visitAsync","visitAsync_","Collection","Node","Value","assign","Alias","Map","Scalar","Seq","Pair","parent","pt","escapeChars","Directives","tags","docStart","docEnd","defaultYaml","defaultTags","clone","copy","atDocument","atNextDocument","add","onError","parts","verbatim","suffix","tagString","entries","doc","tagEntries","tagNames","_key","tn","anchorIsValid","sa","anchorNames","anchors","Set","findNewAnchor","exclude","has","applyReviver","reviver","val","v0","k","get","toJS","ctx","toJSON","aliasCount","onCreate","keep","NodeBase","getPrototypeOf","getOwnPropertyDescriptors","range","mapAsMap","maxAliasCount","onAnchor","mapKeyWarned","values","super","found","_arg","msg","ReferenceError","getAliasCount","_onComment","_onChompKeep","src","verifyAliasOrder","implicitKey","kc","vc","isScalarValue","createNode","Boolean","BigInt","valueOf","aliasDuplicateObjects","onTagObj","sourceObjects","tagObj","identify","findTagObject","nodeClass","default","collectionFromPath","isInteger","keepUndefined","BLOCK_FOLDED","BLOCK_LITERAL","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","isEmptyPath","it","addIn","rest","deleteIn","getIn","keepScalar","hasAllNullValues","allowScalar","every","commentBefore","comment","hasIn","setIn","stringifyComment","indentComment","lineComment","FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","foldFlowLines","mode","indentAtStart","minContentWidth","onFold","onOverflow","endStep","folds","escapedFolds","overflow","escStart","escEnd","consumeMoreIndentedLines","j","fold","getFoldOptions","isBlock","containsDocumentMarker","doubleQuotedString","doubleQuotedAsJSON","minMultiLineLength","doubleQuotedMinMultiLineLength","substr","singleQuotedString","singleQuote","quotedString","qs","hasDouble","hasSingle","blockEndNewlines","blockString","onComment","onChompKeep","blockQuote","commentString","forceBlockIndent","literal","indentLength","limit","strLen","lineLengthOverLimit","chomp","endStart","endNlPos","startEnd","startWithSpace","startNlPos","header","foldedValue","literalFallback","foldOptions","body","stringifyString","inFlow","ss","_stringify","_type","actualString","indentStep","compat","plainString","defaultKeyType","defaultStringType","createStringifyContext","opt","directives","falseStr","flowCollectionPadding","indentSeq","nullStr","simpleKeys","trueStr","toStringOptions","collectionStyle","resolvedAliases","testMatch","getTagObject","props","stringifyProps","warn","logLevel","warning","MERGE_KEY","addToJSMap","addMergeToJSMap","mergeValue","srcMap","addPairToJSMap","isMergeKey","jsKey","stringKey","strCtx","inStringifyKey","strKey","jsonStr","stringifyKey","jsValue","createPair","_","allNullValues","keyComment","explicitKey","vsb","vcb","valueComment","keyCommentDone","chompKeep","spaceBefore","flow","valueCommentDone","valueStr","vs0","nl0","hasNewline","hasPropsLine","sp0","stringifyPair","stringifyCollection","stringifyFlowCollection","stringifyBlockCollection","blockItemPrefix","flowChars","itemIndent","itemCtx","addCommentBefore","ik","fcPadding","reqNewline","linesAtValue","iv","reduce","sum","ic","trimStart","findPair","YAMLMap","sortMapEntries","overwrite","_pair","sortEntries","YAMLSeq","asItemIndex","nullTag","boolTag","stringifyNumber","minFractionDigits","num","isFinite","floatNaN","floatExp","toExponential","dot","intIdentify","intResolve","radix","intAsBigInt","intStringify","intOct","_onError","intHex","stringifyJSON","buf","btoa","ceil","resolvePairs","cn","createPairs","iterable","YAMLOMap","bind","seenKeys","boolStringify","trueTag","falseTag","intBin","YAMLSet","keepPair","parseSexagesimal","asBigInt","p","stringifySexagesimal","_60","unshift","intTime","floatTime","millisec","tz","abs","tagsByName","coreKnownTags","getTags","customTags","schemaName","addMergeTag","schemaTags","sortMapEntriesByKey","resolveKnownTags","toStringDefaults","knownTags","Document","errors","warnings","_replacer","keepSourceTokens","prettyErrors","strict","stringKeys","uniqueKeys","_directives","setSchema","assertCollection","createAlias","keyToStr","asStr","anchorPrefix","setAnchors","aliasObjects","prevAnchors","createNodeAnchors","sv","jsonArg","cs","contentComment","dc","stringifyDocument","YAMLError","YAMLParseError","YAMLWarning","prettifyError","linePos","col","lineStr","pointer","resolveProps","tokens","indicator","startOnNewline","atNewline","hasSpace","commentSep","reqSpace","tab","newlineAfterProp","comma","cb","last","containsNewline","st","flowIndentCheck","fc","mapIncludes","isEqual","startColMsg","resolveEnd","blockMsg","resolveCollection","CN","coll","composeEmptyNode","bm","atRoot","commentEnd","collItem","keyProps","atKey","keyStart","valueProps","srcToken","resolveBlockMap","bs","resolveBlockSeq","fcName","prevItemComment","loop","endRange","expectedEnd","ce","ee","cePos","resolveFlowCollection","Coll","resolveBlockScalar","ts","parseBlockScalarHeader","m","splitLines","chompStart","content","trimIndent","contentStart","crlf","resolveFlowScalar","rel","badChar","foldLines","plainValue","singleQuotedValue","foldNewline","cc","escapeCodes","x","U","parseCharCode","raw","wsStart","doubleQuotedValue","valueEnd","N","L","fromCodePoint","composeScalar","tagToken","matchWithTest","kt","findScalarTagByName","findScalarTagByTest","emptyScalarPosition","before","isSrcToken","composeAlias","nl","lastProp","expType","composeCollection","getErrorPos","parsePrelude","prelude","atComment","afterEmptyLine","Composer","atDirectives","decorate","afterDoc","streamInfo","compose","forceDoc","endOffset","opts","contentEnd","composeDoc","resolveAsScalar","createScalarToken","he","addEndtoBlockProps","setScalarValue","afterKey","setBlockScalarValue","setFlowScalarValue","oa","tok","cst","stringifyToken","stringifyItem","_visit","field","itemAtPath","parentCollection","BOM","DOCUMENT","FLOW_END","prettyToken","tokenType","isEmpty","hexDigits","tagChars","flowIndicatorChars","invalidAnchorChars","isNotAnchorChar","Lexer","atEnd","blockScalarIndent","blockScalarKeep","flowKey","indentNext","indentValue","lineEndPos","lex","incomplete","hasChars","parseNext","atLineEnd","continueScalar","dt","setNext","peek","parseStream","parseLineStart","parseBlockStart","parseDocument","parseFlowCollection","parseQuotedScalar","parseBlockScalar","parsePlainScalar","pushCount","dirEnd","pushSpaces","pushNewline","sp","ch0","ch1","pushIndicators","pushUntil","quote","qb","pushToIndex","lastChar","allowEmpty","pushTag","allowTabs","LineCounter","addNewLine","low","high","mid","includesToken","list","findNonEmptyIndex","isFlowToken","getPrevProps","getFirstKeyStartProps","fixFlowSeqItems","onNewLine","atScalar","onKeyLine","lexer","lexeme","sourceToken","top","stream","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","bv","startBlockValue","atIndentedComment","atMapIndent","atNextItem","flowScalar","parseOptions","lineCounter","parseAllDocuments","parser","composer","docs","_doc","_reviver","round","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","amdO","globalThis","Function","toStringTag","__webpack_exports__"],"sourceRoot":""}